
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>migrate: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/PitiNarak/condormhub-backend/cmd/migrate/main.go (0.0%)</option>
				
				<option value="file1">github.com/PitiNarak/condormhub-backend/docs/docs.go (0.0%)</option>
				
				<option value="file2">github.com/PitiNarak/condormhub-backend/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/PitiNarak/condormhub-backend/internal/core/domain/contract.go (0.0%)</option>
				
				<option value="file4">github.com/PitiNarak/condormhub-backend/internal/core/domain/dorm.go (0.0%)</option>
				
				<option value="file5">github.com/PitiNarak/condormhub-backend/internal/core/domain/leasing_history.go (0.0%)</option>
				
				<option value="file6">github.com/PitiNarak/condormhub-backend/internal/core/domain/leasing_request.go (0.0%)</option>
				
				<option value="file7">github.com/PitiNarak/condormhub-backend/internal/core/domain/order.go (0.0%)</option>
				
				<option value="file8">github.com/PitiNarak/condormhub-backend/internal/core/domain/receipt.go (0.0%)</option>
				
				<option value="file9">github.com/PitiNarak/condormhub-backend/internal/core/domain/sample_log.go (0.0%)</option>
				
				<option value="file10">github.com/PitiNarak/condormhub-backend/internal/core/domain/support.go (0.0%)</option>
				
				<option value="file11">github.com/PitiNarak/condormhub-backend/internal/core/domain/transaction.go (0.0%)</option>
				
				<option value="file12">github.com/PitiNarak/condormhub-backend/internal/core/domain/user.go (0.0%)</option>
				
				<option value="file13">github.com/PitiNarak/condormhub-backend/internal/core/services/contract_service.go (0.0%)</option>
				
				<option value="file14">github.com/PitiNarak/condormhub-backend/internal/core/services/dorm_service.go (4.8%)</option>
				
				<option value="file15">github.com/PitiNarak/condormhub-backend/internal/core/services/leasing_history_service.go (0.0%)</option>
				
				<option value="file16">github.com/PitiNarak/condormhub-backend/internal/core/services/leasing_request_service.go (0.0%)</option>
				
				<option value="file17">github.com/PitiNarak/condormhub-backend/internal/core/services/order_service.go (0.0%)</option>
				
				<option value="file18">github.com/PitiNarak/condormhub-backend/internal/core/services/ownership_proof.go (0.0%)</option>
				
				<option value="file19">github.com/PitiNarak/condormhub-backend/internal/core/services/receipt_service.go (0.0%)</option>
				
				<option value="file20">github.com/PitiNarak/condormhub-backend/internal/core/services/support_service.go (0.0%)</option>
				
				<option value="file21">github.com/PitiNarak/condormhub-backend/internal/core/services/transaction_service.go (0.0%)</option>
				
				<option value="file22">github.com/PitiNarak/condormhub-backend/internal/core/services/user_service.go (0.0%)</option>
				
				<option value="file23">github.com/PitiNarak/condormhub-backend/internal/database/db.go (0.0%)</option>
				
				<option value="file24">github.com/PitiNarak/condormhub-backend/internal/dto/http_response.go (0.0%)</option>
				
				<option value="file25">github.com/PitiNarak/condormhub-backend/internal/handler/contract_handler.go (0.0%)</option>
				
				<option value="file26">github.com/PitiNarak/condormhub-backend/internal/handler/dorm_handler.go (0.0%)</option>
				
				<option value="file27">github.com/PitiNarak/condormhub-backend/internal/handler/example_upload_handler.go (0.0%)</option>
				
				<option value="file28">github.com/PitiNarak/condormhub-backend/internal/handler/greeting_handler.go (0.0%)</option>
				
				<option value="file29">github.com/PitiNarak/condormhub-backend/internal/handler/leasing_history_handler.go (0.0%)</option>
				
				<option value="file30">github.com/PitiNarak/condormhub-backend/internal/handler/leasing_request_handler.go (0.0%)</option>
				
				<option value="file31">github.com/PitiNarak/condormhub-backend/internal/handler/order_handler.go (0.0%)</option>
				
				<option value="file32">github.com/PitiNarak/condormhub-backend/internal/handler/ownership_proof_handler.go (0.0%)</option>
				
				<option value="file33">github.com/PitiNarak/condormhub-backend/internal/handler/receipt_handler.go (0.0%)</option>
				
				<option value="file34">github.com/PitiNarak/condormhub-backend/internal/handler/support_handler.go (0.0%)</option>
				
				<option value="file35">github.com/PitiNarak/condormhub-backend/internal/handler/transaction_handler.go (0.0%)</option>
				
				<option value="file36">github.com/PitiNarak/condormhub-backend/internal/handler/user_handler.go (0.0%)</option>
				
				<option value="file37">github.com/PitiNarak/condormhub-backend/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file38">github.com/PitiNarak/condormhub-backend/internal/repository/contract_repository.go (0.0%)</option>
				
				<option value="file39">github.com/PitiNarak/condormhub-backend/internal/repository/dorm_repository.go (0.0%)</option>
				
				<option value="file40">github.com/PitiNarak/condormhub-backend/internal/repository/leasing_history_repository.go (0.0%)</option>
				
				<option value="file41">github.com/PitiNarak/condormhub-backend/internal/repository/leasing_request_repository.go (0.0%)</option>
				
				<option value="file42">github.com/PitiNarak/condormhub-backend/internal/repository/order_repository.go (0.0%)</option>
				
				<option value="file43">github.com/PitiNarak/condormhub-backend/internal/repository/ownership_proof_repository.go (0.0%)</option>
				
				<option value="file44">github.com/PitiNarak/condormhub-backend/internal/repository/receipt_repository.go (0.0%)</option>
				
				<option value="file45">github.com/PitiNarak/condormhub-backend/internal/repository/sample_log_repository.go (0.0%)</option>
				
				<option value="file46">github.com/PitiNarak/condormhub-backend/internal/repository/support_repository.go (0.0%)</option>
				
				<option value="file47">github.com/PitiNarak/condormhub-backend/internal/repository/transaction_repository.go (0.0%)</option>
				
				<option value="file48">github.com/PitiNarak/condormhub-backend/internal/repository/user_repository.go (0.0%)</option>
				
				<option value="file49">github.com/PitiNarak/condormhub-backend/internal/server/handler.go (0.0%)</option>
				
				<option value="file50">github.com/PitiNarak/condormhub-backend/internal/server/repository.go (0.0%)</option>
				
				<option value="file51">github.com/PitiNarak/condormhub-backend/internal/server/route.go (0.0%)</option>
				
				<option value="file52">github.com/PitiNarak/condormhub-backend/internal/server/server.go (0.0%)</option>
				
				<option value="file53">github.com/PitiNarak/condormhub-backend/internal/server/service.go (0.0%)</option>
				
				<option value="file54">github.com/PitiNarak/condormhub-backend/main.go (0.0%)</option>
				
				<option value="file55">github.com/PitiNarak/condormhub-backend/pkg/email/sender.go (0.0%)</option>
				
				<option value="file56">github.com/PitiNarak/condormhub-backend/pkg/jwt/jwt.go (0.0%)</option>
				
				<option value="file57">github.com/PitiNarak/condormhub-backend/pkg/redis/redis.go (0.0%)</option>
				
				<option value="file58">github.com/PitiNarak/condormhub-backend/pkg/redis/token.go (0.0%)</option>
				
				<option value="file59">github.com/PitiNarak/condormhub-backend/pkg/storage/storage.go (0.0%)</option>
				
				<option value="file60">github.com/PitiNarak/condormhub-backend/pkg/stripe/stripe.go (0.0%)</option>
				
				<option value="file61">github.com/PitiNarak/condormhub-backend/pkg/swagger/handler.go (0.0%)</option>
				
				<option value="file62">github.com/PitiNarak/condormhub-backend/pkg/utils/validation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"

        "github.com/PitiNarak/condormhub-backend/internal/config"
        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/gofiber/fiber/v2/log"
)

func CreateEnum(db *database.Database) <span class="cov0" title="0">{
        query := `
    DO $$ BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'lifestyle_tag') THEN
            CREATE TYPE lifestyle_tag AS ENUM (
                'Active',
                'Creative',
                'Social',
                'Relaxed',

                'Football',
                'Basketball',
                'Tennis',
                'Swimming',
                'Running',
                'Cycling',
                'Badminton',
                'Yoga',
                'Gym &amp; Fitness',

                'Music',
                'Dancing',
                'Photography',
                'Painting',
                'Gaming',
                'Reading',
                'Writing',
                'DIY &amp; Crafting',
                'Cooking',

                'Extrovert',
                'Introvert',
                'Night Owl',
                'Early Bird',

                'Traveler',
                'Backpacker',
                'Nature Lover',
                'Camping',
                'Beach Lover',

                'Dog Lover',
                'Cat Lover',

                'Freelancer',
                'Entrepreneur',
                'Office Worker',
                'Remote Worker',
                'Student',
                'Self-Employed'
            );
        END IF;
    END $$;
    `
        db.Exec(query)
}</span>

func main() <span class="cov0" title="0">{
        config := config.Load()

        db, err := database.New(config.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Database connection failed: %v", err)
        }</span>

        <span class="cov0" title="0">CreateEnum(db)
        db.Exec("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";")

        if err := db.AutoMigrate(
                &amp;domain.SampleLog{},
                &amp;domain.User{},
                &amp;domain.Transaction{},
                &amp;domain.Dorm{},
                &amp;domain.LeasingHistory{},
                &amp;domain.Order{},
                &amp;domain.DormImage{},
                &amp;domain.OwnershipProof{},
                &amp;domain.Contract{},
                &amp;domain.LeasingRequest{},
                &amp;domain.Review{},
                &amp;domain.ReviewImage{},
                &amp;domain.Receipt{},
                &amp;domain.SupportRequest{},
        ); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Migration failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Migration completed")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag/v2"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "components": {"schemas":{"dto.Address":{"properties":{"district":{"type":"string"},"province":{"type":"string"},"subdistrict":{"type":"string"},"zipcode":{"type":"string"}},"type":"object"},"dto.ContractResponseBody":{"properties":{"contractStatus":{"type":"string","x-enum-varnames":["Waiting","Signed","Cancelled"]},"dorm":{"$ref":"#/components/schemas/dto.DormResponseBody"},"id":{"type":"string"},"lessee":{"$ref":"#/components/schemas/dto.UserResponse"},"lesseeStatus":{"type":"string","x-enum-varnames":["Waiting","Signed","Cancelled"]},"lessorStatus":{"$ref":"#/components/schemas/dto.ContractStatus"}},"type":"object"},"dto.ContractStatus":{"type":"string","x-enum-varnames":["Waiting","Signed","Cancelled"]},"dto.CreateTransactionResponseBody":{"properties":{"checkoutUrl":{"type":"string"}},"type":"object"},"dto.DormCreateRequestBody":{"properties":{"address":{"properties":{"district":{"type":"string"},"province":{"type":"string"},"subdistrict":{"type":"string"},"zipcode":{"type":"string"}},"required":["district","province","subdistrict","zipcode"],"type":"object"},"bathrooms":{"minimum":0,"type":"integer"},"bedrooms":{"minimum":0,"type":"integer"},"description":{"type":"string"},"name":{"type":"string"},"price":{"type":"number"},"size":{"type":"number"}},"required":["address","bathrooms","bedrooms","name","price","size"],"type":"object"},"dto.DormImageUploadResponseBody":{"properties":{"url":{"items":{"type":"string"},"type":"array","uniqueItems":false}},"type":"object"},"dto.DormResponseBody":{"properties":{"address":{"$ref":"#/components/schemas/dto.Address"},"bathrooms":{"type":"integer"},"bedrooms":{"type":"integer"},"createAt":{"type":"string"},"description":{"type":"string"},"id":{"type":"string"},"imagesUrl":{"items":{"type":"string"},"type":"array","uniqueItems":false},"name":{"type":"string"},"owner":{"$ref":"#/components/schemas/dto.UserResponse"},"price":{"type":"number"},"rating":{"type":"number"},"size":{"type":"number"},"updateAt":{"type":"string"}},"type":"object"},"dto.DormUpdateRequestBody":{"properties":{"address":{"$ref":"#/components/schemas/dto.Address"},"bathrooms":{"minimum":0,"type":"integer"},"bedrooms":{"minimum":0,"type":"integer"},"description":{"type":"string"},"name":{"type":"string"},"price":{"type":"number"},"size":{"type":"number"}},"type":"object"},"dto.ErrorResponse":{"properties":{"error":{"type":"string"}},"type":"object"},"dto.LeasingHistory":{"properties":{"dorm":{"$ref":"#/components/schemas/dto.DormResponseBody"},"end":{"type":"string"},"id":{"type":"string"},"lessee":{"$ref":"#/components/schemas/dto.UserResponse"},"orders":{"items":{"$ref":"#/components/schemas/dto.OrderResponseBody"},"type":"array","uniqueItems":false},"price":{"type":"number"},"review":{"$ref":"#/components/schemas/dto.Review"},"reviewFlag":{"type":"boolean"},"reviewImages":{"items":{"type":"string"},"type":"array","uniqueItems":false},"start":{"type":"string"}},"type":"object"},"dto.LeasingRequest":{"properties":{"dorm":{"$ref":"#/components/schemas/dto.DormResponseBody"},"end":{"type":"string"},"id":{"type":"string"},"lessee":{"$ref":"#/components/schemas/dto.UserResponse"},"message":{"type":"string"},"start":{"type":"string"},"status":{"$ref":"#/components/schemas/dto.Status"}},"type":"object"},"dto.LeasingRequestCreateRequestBody":{"properties":{"message":{"type":"string"}},"type":"object"},"dto.LessorIncomeResponseBody":{"properties":{"income":{"type":"number"}},"type":"object"},"dto.LoginRequestBody":{"properties":{"email":{"type":"string"},"password":{"type":"string"}},"required":["email","password"],"type":"object"},"dto.OrderRequestBody":{"properties":{"leasingHistoryId":{"type":"string"}},"required":["leasingHistoryId"],"type":"object"},"dto.OrderResponseBody":{"properties":{"id":{"type":"string"},"paidTransaction":{"$ref":"#/components/schemas/dto.TransactionResponse"},"price":{"type":"integer"},"type":{"type":"string"}},"type":"object"},"dto.OwnershipProofResponseBody":{"properties":{"adminId":{"type":"string"},"dormId":{"type":"string"},"status":{"$ref":"#/components/schemas/dto.OwnershipProofStatus"},"url":{"type":"string"}},"type":"object"},"dto.OwnershipProofStatus":{"type":"string","x-enum-varnames":["Pending","Approved","Rejected"]},"dto.Pagination":{"properties":{"current_page":{"type":"integer"},"last_page":{"type":"integer"},"limit":{"type":"integer"},"total":{"type":"integer"}},"type":"object"},"dto.PaginationResponse-dto_ContractResponseBody":{"properties":{"data":{"items":{"$ref":"#/components/schemas/dto.ContractResponseBody"},"type":"array","uniqueItems":false},"pagination":{"$ref":"#/components/schemas/dto.Pagination"}},"type":"object"},"dto.PaginationResponse-dto_DormResponseBody":{"properties":{"data":{"items":{"$ref":"#/components/schemas/dto.DormResponseBody"},"type":"array","uniqueItems":false},"pagination":{"$ref":"#/components/schemas/dto.Pagination"}},"type":"object"},"dto.PaginationResponse-dto_LeasingHistory":{"properties":{"data":{"items":{"$ref":"#/components/schemas/dto.LeasingHistory"},"type":"array","uniqueItems":false},"pagination":{"$ref":"#/components/schemas/dto.Pagination"}},"type":"object"},"dto.PaginationResponse-dto_LeasingRequest":{"properties":{"data":{"items":{"$ref":"#/components/schemas/dto.LeasingRequest"},"type":"array","uniqueItems":false},"pagination":{"$ref":"#/components/schemas/dto.Pagination"}},"type":"object"},"dto.PaginationResponse-dto_OrderResponseBody":{"properties":{"data":{"items":{"$ref":"#/components/schemas/dto.OrderResponseBody"},"type":"array","uniqueItems":false},"pagination":{"$ref":"#/components/schemas/dto.Pagination"}},"type":"object"},"dto.PaginationResponse-dto_ReceiptResponseBody":{"properties":{"data":{"items":{"$ref":"#/components/schemas/dto.ReceiptResponseBody"},"type":"array","uniqueItems":false},"pagination":{"$ref":"#/components/schemas/dto.Pagination"}},"type":"object"},"dto.PaginationResponse-dto_ReportedReview":{"properties":{"data":{"items":{"$ref":"#/components/schemas/dto.ReportedReview"},"type":"array","uniqueItems":false},"pagination":{"$ref":"#/components/schemas/dto.Pagination"}},"type":"object"},"dto.PaginationResponse-dto_StudentEvidenceResponse":{"properties":{"data":{"items":{"$ref":"#/components/schemas/dto.StudentEvidenceResponse"},"type":"array","uniqueItems":false},"pagination":{"$ref":"#/components/schemas/dto.Pagination"}},"type":"object"},"dto.PaginationResponse-dto_SupportResponseBody":{"properties":{"data":{"items":{"$ref":"#/components/schemas/dto.SupportResponseBody"},"type":"array","uniqueItems":false},"pagination":{"$ref":"#/components/schemas/dto.Pagination"}},"type":"object"},"dto.ProfilePictureUploadResponseBody":{"properties":{"url":{"type":"string"}},"type":"object"},"dto.ReceiptResponseBody":{"properties":{"owner":{"$ref":"#/components/schemas/dto.UserResponse"},"receiptId":{"type":"string"},"transaction":{"$ref":"#/components/schemas/dto.TransactionResponse"},"url":{"type":"string"}},"type":"object"},"dto.RefreshTokenRequestBody":{"properties":{"refreshToken":{"type":"string"}},"required":["refreshToken"],"type":"object"},"dto.RegisterRequestBody":{"properties":{"email":{"type":"string"},"password":{"type":"string"},"username":{"type":"string"}},"required":["email","password","username"],"type":"object"},"dto.ReportedReview":{"properties":{"createAt":{"type":"string"},"historyId":{"type":"string"},"message":{"type":"string"},"rate":{"type":"integer"},"reviewer":{"$ref":"#/components/schemas/dto.UserResponse"},"url":{"items":{"type":"string"},"type":"array","uniqueItems":false}},"type":"object"},"dto.ResetPasswordCreateRequestBody":{"properties":{"email":{"type":"string"}},"required":["email"],"type":"object"},"dto.ResetPasswordRequestBody":{"properties":{"password":{"type":"string"},"token":{"type":"string"}},"required":["password","token"],"type":"object"},"dto.Review":{"properties":{"createAt":{"type":"string"},"message":{"type":"string"},"rate":{"type":"integer"},"reported":{"type":"boolean"},"url":{"items":{"type":"string"},"type":"array","uniqueItems":false}},"type":"object"},"dto.ReviewCreateRequestBody":{"properties":{"message":{"type":"string"},"rate":{"maximum":5,"minimum":0,"type":"integer"},"url":{"items":{"type":"string"},"type":"array","uniqueItems":false}},"required":["message","rate"],"type":"object"},"dto.ReviewImageUploadResponseBody":{"properties":{"url":{"items":{"type":"string"},"type":"array","uniqueItems":false}},"type":"object"},"dto.ReviewUpdateRequestBody":{"properties":{"message":{"type":"string"},"rate":{"maximum":5,"minimum":0,"type":"integer"},"url":{"items":{"type":"string"},"type":"array","uniqueItems":false}},"type":"object"},"dto.Role":{"type":"string","x-enum-varnames":["AdminRole","LesseeRole","LessorRole"]},"dto.Status":{"type":"string","x-enum-varnames":["RequestPending","RequestAccepted","RequestRejected","RequestCanceled"]},"dto.StudentEvidenceResponse":{"properties":{"evidence":{"$ref":"#/components/schemas/dto.StudentEvidenceUploadResponseBody"},"user":{"$ref":"#/components/schemas/dto.UserResponse"}},"type":"object"},"dto.StudentEvidenceUploadResponseBody":{"properties":{"expired":{"type":"string"},"url":{"type":"string"}},"type":"object"},"dto.SuccessResponse-dto_ContractResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.ContractResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_CreateTransactionResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.CreateTransactionResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_DormImageUploadResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.DormImageUploadResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_DormResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.DormResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_LeasingHistory":{"properties":{"data":{"$ref":"#/components/schemas/dto.LeasingHistory"}},"type":"object"},"dto.SuccessResponse-dto_LeasingRequest":{"properties":{"data":{"$ref":"#/components/schemas/dto.LeasingRequest"}},"type":"object"},"dto.SuccessResponse-dto_LessorIncomeResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.LessorIncomeResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_OrderResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.OrderResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_OwnershipProofResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.OwnershipProofResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_ProfilePictureUploadResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.ProfilePictureUploadResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_Review":{"properties":{"data":{"$ref":"#/components/schemas/dto.Review"}},"type":"object"},"dto.SuccessResponse-dto_ReviewImageUploadResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.ReviewImageUploadResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_StudentEvidenceResponse":{"properties":{"data":{"$ref":"#/components/schemas/dto.StudentEvidenceResponse"}},"type":"object"},"dto.SuccessResponse-dto_StudentEvidenceUploadResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.StudentEvidenceUploadResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_SupportResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.SupportResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_TokenResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.TokenResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_TokenWithUserInformationResponseBody":{"properties":{"data":{"$ref":"#/components/schemas/dto.TokenWithUserInformationResponseBody"}},"type":"object"},"dto.SuccessResponse-dto_UserResponse":{"properties":{"data":{"$ref":"#/components/schemas/dto.UserResponse"}},"type":"object"},"dto.SupportRequestBody":{"properties":{"message":{"type":"string"}},"required":["message"],"type":"object"},"dto.SupportResponseBody":{"properties":{"createAt":{"type":"string"},"id":{"type":"string"},"message":{"type":"string"},"status":{"type":"string"},"updateAt":{"type":"string"},"userID":{"type":"string"}},"type":"object"},"dto.TokenResponseBody":{"properties":{"accessToken":{"type":"string"},"refreshToken":{"type":"string"}},"type":"object"},"dto.TokenWithUserInformationResponseBody":{"properties":{"accessToken":{"type":"string"},"refreshToken":{"type":"string"},"userInformation":{"$ref":"#/components/schemas/dto.UserResponse"}},"type":"object"},"dto.TransactionRequestBody":{"properties":{"orderID":{"type":"string"}},"type":"object"},"dto.TransactionResponse":{"properties":{"createAt":{"type":"string"},"id":{"type":"string"},"price":{"type":"integer"},"status":{"type":"string"},"updateAt":{"type":"string"}},"type":"object"},"dto.UpdateStatusRequestBody":{"properties":{"status":{"type":"string"}},"required":["status"],"type":"object"},"dto.UserFirstFillRequestBody":{"properties":{"birthDate":{"type":"string"},"firstname":{"minLength":2,"type":"string"},"gender":{"type":"string"},"lastname":{"minLength":2,"type":"string"},"lifestyles":{"items":{"type":"string"},"type":"array","uniqueItems":false},"nationalID":{"type":"string"},"phoneNumber":{"type":"string"},"role":{"$ref":"#/components/schemas/dto.Role"}},"type":"object"},"dto.UserInformationRequestBody":{"properties":{"birthDate":{"type":"string"},"firstname":{"minLength":2,"type":"string"},"gender":{"type":"string"},"lastname":{"minLength":2,"type":"string"},"lifestyles":{"items":{"type":"string"},"type":"array","uniqueItems":false},"nationalID":{"type":"string"},"password":{"minLength":8,"type":"string"},"phoneNumber":{"type":"string"},"studentEvidence":{"type":"string"},"username":{"minLength":2,"type":"string"}},"type":"object"},"dto.UserResponse":{"properties":{"banned":{"type":"boolean"},"birthDate":{"type":"string"},"createAt":{"type":"string"},"dorms_leased":{"type":"integer"},"dorms_owned":{"type":"integer"},"email":{"type":"string"},"filledPersonalInfo":{"type":"boolean"},"firstname":{"type":"string"},"gender":{"type":"string"},"id":{"type":"string"},"isStudentVerified":{"type":"string"},"isVerified":{"type":"boolean"},"lastname":{"type":"string"},"lifestyles":{"items":{"type":"string"},"type":"array","uniqueItems":false},"phoneNumber":{"type":"string"},"profilePicUrl":{"type":"string"},"review_count":{"type":"integer"},"role":{"type":"string"},"username":{"type":"string"}},"type":"object"},"dto.VerifyRequestBody":{"properties":{"token":{"type":"string"}},"required":["token"],"type":"object"}},"securitySchemes":{"Bearer":{"description":"Bearer token authentication","in":"header","name":"Authorization","type":"apiKey"}}},
    "info": {"description":"{{escape .Description}}","title":"{{.Title}}","version":"{{.Version}}"},
    "externalDocs": {"description":"","url":""},
    "paths": {"/admin/lessee/pending":{"get":{"description":"Get all pending student verifications","parameters":[{"description":"Number of pending verification to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_StudentEvidenceResponse"}}},"description":"All pending verification retrieved"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"forbidden"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"internal server error"}},"security":[{"Bearer":[]}],"summary":"Get all pending student verifications","tags":["admin"]}},"/admin/lessee/{id}/reject":{"patch":{"description":"Reject a lessee student verification","parameters":[{"description":"lesseeID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_StudentEvidenceResponse"}}},"description":"Lessee rejected"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"bad request"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"forbidden"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"not found"},"409":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"confilct"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"internal server error"}},"security":[{"Bearer":[]}],"summary":"Reject a lessee student verification","tags":["admin"]}},"/admin/lessee/{id}/verify":{"patch":{"description":"Verify a lessee student verification","parameters":[{"description":"lesseeID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_StudentEvidenceResponse"}}},"description":"Lessee verified"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"bad request"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"forbidden"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"not found"},"409":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"confilct"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"internal server error"}},"security":[{"Bearer":[]}],"summary":"Verify a lessee student verification","tags":["admin"]}},"/admin/reviews/reported":{"get":{"description":"Endpoint for admins to get a list of all reported reviews","parameters":[{"description":"Number of reviews to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_ReportedReview"}}},"description":"Retrieve reported reviews successfully"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"forbidden"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"internal server error"}},"security":[{"Bearer":[]}],"summary":"Get all reported reviews","tags":["admin"]}},"/admin/user/{id}/ban":{"patch":{"description":"Ban a user by their ID. Only admins are allowed to use this endpoint","parameters":[{"description":"userID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_UserResponse"}}},"description":"User banned"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"bad request"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"forbidden"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"not found"},"409":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"confilct"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"internal server error"}},"security":[{"Bearer":[]}],"summary":"Ban a user","tags":["admin"]}},"/admin/user/{id}/unban":{"patch":{"description":"Unban a user by their ID. Only admins are allowed to use this endpoint","parameters":[{"description":"userID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_UserResponse"}}},"description":"User unbanned"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"bad request"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"forbidden"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"not found"},"409":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"confilct"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"internal server error"}},"security":[{"Bearer":[]}],"summary":"Unban a user","tags":["admin"]}},"/auth/login":{"post":{"description":"Login user","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.LoginRequestBody"}}},"description":"user information","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_TokenWithUserInformationResponseBody"}}},"description":"user successfully logged in"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"user not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot login user"}},"summary":"Login user","tags":["auth"]}},"/auth/refresh":{"post":{"description":"Refresh user","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.RefreshTokenRequestBody"}}},"description":"user information","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_TokenResponseBody"}}},"description":"user successfully Refresh in"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"user not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot refresh user"}},"summary":"Refresh user","tags":["auth"]}},"/auth/register":{"post":{"description":"Register new user","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.RegisterRequestBody"}}},"description":"user information","required":true},"responses":{"201":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_TokenWithUserInformationResponseBody"}}},"description":"user successfully registered"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot register user"}},"summary":"Register new user","tags":["auth"]}},"/contract":{"get":{"description":"Get all contracts associated with a specific user","parameters":[{"description":"Number of contracts to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_ContractResponseBody"}}},"description":"Contracts retrieved successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid query parameters"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to retrieve contracts"}},"security":[{"Bearer":[]}],"summary":"Retrieve contracts by user ID","tags":["contracts"]}},"/contract/{contractID}":{"delete":{"description":"Permanently delete a contract by ID","parameters":[{"description":"Contract ID","in":"path","name":"contractID","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"Contract deleted successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid contract ID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to delete contract"}},"security":[{"Bearer":[]}],"summary":"Delete a contract","tags":["contracts"]},"get":{"description":"Get details of a specific contract","parameters":[{"description":"Contract ID","in":"path","name":"contractID","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_ContractResponseBody"}}},"description":"Contract retrieved successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid contract ID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to retrieve contract"}},"security":[{"Bearer":[]}],"summary":"Retrieve a contract by contract ID","tags":["contracts"]}},"/contract/{contractID}/cancel":{"patch":{"description":"Cancel a contract if it is not signed","parameters":[{"description":"Contract ID","in":"path","name":"contractID","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_ContractResponseBody"}}},"description":"Contract cancelled successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid contract ID format or contract cannot be cancelled"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to cancel contract"}},"security":[{"Bearer":[]}],"summary":"Cancel an existing contract","tags":["contracts"]}},"/contract/{contractID}/sign":{"patch":{"description":"Sign a contract by providing contract ID","parameters":[{"description":"Contract ID","in":"path","name":"contractID","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_ContractResponseBody"}}},"description":"Contract signed successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid contract ID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to sign contract"}},"security":[{"Bearer":[]}],"summary":"Sign an existing contract","tags":["contracts"]}},"/contract/{dormID}":{"get":{"description":"Get all contracts associated with a specific dorm","parameters":[{"description":"Dorm ID","in":"path","name":"dormId","required":true,"schema":{"type":"string"}},{"description":"Number of contracts to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_ContractResponseBody"}}},"description":"Contracts retrieved successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid dorm ID format or query parameters"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to retrieve contracts"}},"security":[{"Bearer":[]}],"summary":"Retrieve contracts by dorm ID","tags":["contracts"]}},"/dorms":{"get":{"description":"Retrieve a list of all dorms filtered by a search query. If no query is provided, all dorms are returned.","parameters":[{"description":"Search query","in":"query","name":"search","schema":{"type":"string"}},{"description":"Filter min price","in":"query","name":"minPrice","schema":{"type":"integer"}},{"description":"Filter max price","in":"query","name":"maxPrice","schema":{"type":"integer"}},{"description":"Filter district price","in":"query","name":"district","schema":{"type":"string"}},{"description":"Filter subdistrict price","in":"query","name":"subdistrict","schema":{"type":"string"}},{"description":"Filter province price","in":"query","name":"province","schema":{"type":"string"}},{"description":"Filter zipcode price","in":"query","name":"zipcode","schema":{"type":"string"}},{"description":"Number of dorms to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_DormResponseBody"}}},"description":"All dorms retrieved successfully"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to retrieve dorms"}},"summary":"Get all dorms by a search string","tags":["dorms"]},"post":{"description":"Add a new room to the database with the given details","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.DormCreateRequestBody"}}},"description":"Dorm information","required":true},"responses":{"201":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_DormResponseBody"}}},"description":"Dorm successfully created"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"You do not have permission to create a dorm"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to save dorm"}},"security":[{"Bearer":[]}],"summary":"Create a new dorm","tags":["dorms"]}},"/dorms/images/{url}":{"delete":{"description":"Deletes a dorm image using its percent encoded url from bucket storage. Encode URL using the encodeURIComponent() function.","parameters":[{"description":"Percent encoded URL","in":"path","name":"url","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"type":"object"}}}},"responses":{"204":{"description":"Image deleted successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"You do not have permission to delete this dorm image"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Image not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to delete image"}},"security":[{"Bearer":[]}],"summary":"Delete a dorm image by its url","tags":["dorms"]}},"/dorms/owner/{id}":{"get":{"description":"Retrieve all dorms of a specific owner ID","parameters":[{"description":"OwnerID","in":"path","name":"id","required":true,"schema":{"type":"string"}},{"description":"Number of dorms to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_DormResponseBody"}}},"description":"All dorms retrieved successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to retrieve dorms"}},"summary":"Get dorms by owner ID","tags":["dorms"]}},"/dorms/{id}":{"delete":{"description":"Removes a dorm from the database based on the give ID","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"Dorm successfully deleted"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"You do not have permission to delete this dorm"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Dorm not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to delete dorm"}},"security":[{"Bearer":[]}],"summary":"Delete a dorm","tags":["dorms"]},"get":{"description":"Retrieve a specific dorm based on its ID","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_DormResponseBody"}}},"description":"Dorm data successfully retrieved"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Dorm not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Server failed to retrieve dorm"}},"summary":"Get a dorm by ID","tags":["dorms"]},"patch":{"description":"Modifies an existing room's details based on the given ID","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.DormUpdateRequestBody"}}},"description":"Updated Room Data","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_DormResponseBody"}}},"description":"Dorm data updated successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid Request"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized to update this dorm"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Dorm not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Server failed to update dorm"}},"security":[{"Bearer":[]}],"summary":"Update an existing dorm","tags":["dorms"]}},"/dorms/{id}/images":{"post":{"description":"Upload multiple images for a specific dorm by its ID, by attaching the images as value for the key field name \"image\", as a multipart form-data","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"multipart/form-data":{"schema":{"type":"file"}}},"description":"DormImage","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_DormImageUploadResponseBody"}}},"description":"Successful image upload"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid Request"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized to upload image to dorm"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Dorm not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Server failed to upload dorm image"}},"security":[{"Bearer":[]}],"summary":"Upload multiple images for a dorm","tags":["dorms"]}},"/history/bydorm/{id}":{"get":{"description":"Retrieve a list of all leasing history by dormid","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}},{"description":"Number of leasing histories to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_LeasingHistory"}}},"description":"Retrive history successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format or limit parameter is incorrect or page parameter is incorrect or page exceeded"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID"}},"security":[{"Bearer":[]}],"summary":"Get all leasing history by dormid","tags":["history"]}},"/history/me":{"get":{"description":"Retrieve a list of all leasing history of current user","parameters":[{"description":"Number of leasing histories to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_LeasingHistory"}}},"description":"Retrive history successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format or limit parameter is incorrect or page parameter is incorrect or page exceeded"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"}},"security":[{"Bearer":[]}],"summary":"Get all leasing history of current user","tags":["history"]}},"/history/review/image/{url}":{"delete":{"description":"Deletes a review image using its percent encoded url from bucket storage. Encode URL using encodeURIComponent().","parameters":[{"description":"Percent encoded URL","in":"path","name":"url","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"Image deleted successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"You do not have permission to delete this review image"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Image not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to delete image"}},"security":[{"Bearer":[]}],"summary":"Delete a review image by its url","tags":["history"]}},"/history/{id}":{"delete":{"description":"Delete a leasing history in the database","parameters":[{"description":"LeasingHistoryId","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"No Content"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or Failed to delete leasing history"}},"security":[{"Bearer":[]}],"summary":"Delete a leasing history","tags":["history"]},"get":{"description":"Retrieve a leasing history by historyid","parameters":[{"description":"HistoryID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.LeasingHistory"}}},"description":"Retrive history successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID"}},"security":[{"Bearer":[]}],"summary":"Get a leasing history by historyid","tags":["history"]},"patch":{"description":"Set end date of a leasing history in the database","parameters":[{"description":"LeasingHistoryId","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"Set end timestamp successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or Failed to update leasing history"}},"security":[{"Bearer":[]}],"summary":"Set end date of a leasing history","tags":["history"]},"post":{"description":"Add a new leasing history to the database","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"201":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_LeasingHistory"}}},"description":"Dorm successfully created"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Dorm not found or leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or failed to save leasing history to database"}},"security":[{"Bearer":[]}],"summary":"Create a new leasing history","tags":["history"]}},"/history/{id}/review":{"delete":{"description":"Delete a review","parameters":[{"description":"HistoryID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"No Content"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Dorm not found or leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or failed to save leasing history to database"}},"security":[{"Bearer":[]}],"summary":"Delete a review","tags":["history"]},"patch":{"description":"Update a review in the database","parameters":[{"description":"HistoryID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ReviewUpdateRequestBody"}}},"description":"review information","required":true},"responses":{"201":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_Review"}}},"description":"Created"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format or your request is invalid or review not exist"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or failed to save leasing history to database"}},"security":[{"Bearer":[]}],"summary":"Update a new review","tags":["history"]},"post":{"description":"Add a new review to the database","parameters":[{"description":"HistoryID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ReviewCreateRequestBody"}}},"description":"review information","required":true},"responses":{"201":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_Review"}}},"description":"Created"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format or your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or failed to save leasing history to database"}},"security":[{"Bearer":[]}],"summary":"Create a new review","tags":["history"]}},"/history/{id}/review/images":{"post":{"description":"Upload multiple images for a specific review by its historyID, by attaching the images as value for the key field name \"image\", as a multipart form-data","parameters":[{"description":"historyID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"multipart/form-data":{"schema":{"type":"file"}}},"description":"ReviewImage","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_ReviewImageUploadResponseBody"}}},"description":"Successful image upload"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid Request"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized to upload image to review"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"History not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Server failed to upload review image"}},"security":[{"Bearer":[]}],"summary":"Upload multiple images for a review","tags":["history"]}},"/history/{id}/review/report":{"post":{"description":"Mark a review as reported","parameters":[{"description":"HistoryID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_Review"}}},"description":"Review reported successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"bad request"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"forbidden"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"not found"},"409":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"conflict"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"internal server error"}},"security":[{"Bearer":[]}],"summary":"Report a review","tags":["history"]}},"/order":{"post":{"description":"Create an order","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.OrderRequestBody"}}},"description":"Order request body","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_OrderResponseBody"}}},"description":"Order created successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"cannot parse uuid or cannot delete user"}},"security":[{"Bearer":[]}],"summary":"Create an order","tags":["order"]}},"/order/unpaid/me":{"get":{"description":"Get my unpaid orders by ID","parameters":[{"description":"Number of history to be retrieved","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page to retrieved","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_OrderResponseBody"}}},"description":"Unpaid orders retrieved successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"cannot parse uuid or cannot delete user"}},"security":[{"Bearer":[]}],"summary":"Get my unpaid orders by ID","tags":["order"]}},"/order/unpaid/{userID}":{"get":{"description":"Get unpaid orders by User ID","parameters":[{"description":"User ID","in":"path","name":"userID","required":true,"schema":{"type":"string"}},{"description":"Number of history to be retrieved","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page to retrieved","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_OrderResponseBody"}}},"description":"Order retrieved successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"cannot parse uuid or cannot delete user"}},"security":[{"Bearer":[]}],"summary":"Get unpaid orders by User ID","tags":["order"]}},"/order/{id}":{"get":{"description":"Get an order by ID","parameters":[{"description":"Order ID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_OrderResponseBody"}}},"description":"Order retrieved successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"cannot parse uuid or cannot delete user"}},"security":[{"Bearer":[]}],"summary":"Get an order by ID","tags":["order"]}},"/ownership/{id}":{"delete":{"description":"Delete an ownership proof file","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"Ownership proof successfully deleted"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Ownership file not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to delete Ownership file"}},"security":[{"Bearer":[]}],"summary":"Delete ownership proof","tags":["ownership"]},"get":{"description":"Retrieve ownership proof for a specific dorm","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_OwnershipProofResponseBody"}}},"description":"Ownership proof retrieved successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Ownership file not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Internal server error"}},"security":[{"Bearer":[]}],"summary":"Get ownership proof by Dorm ID","tags":["ownership"]}},"/ownership/{id}/approve":{"post":{"description":"Approve a submitted ownership proof for a dorm","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_OwnershipProofResponseBody"}}},"description":"Ownership proof approved"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Ownership file not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Internal server error"}},"security":[{"Bearer":[]}],"summary":"Approve ownership proof","tags":["ownership"]}},"/ownership/{id}/reject":{"post":{"description":"Reject a submitted ownership proof for a dorm","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_OwnershipProofResponseBody"}}},"description":"Ownership proof rejected"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Ownership file not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Internal server error"}},"security":[{"Bearer":[]}],"summary":"Reject ownership proof","tags":["ownership"]}},"/ownership/{id}/upload":{"post":{"description":"Upload a new file as ownership proof for a dorm","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"multipart/form-data":{"schema":{"type":"file"}}},"description":"file","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_OwnershipProofResponseBody"}}},"description":"Ownership proof created"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Ownershop proof not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Server failed to upload file"}},"security":[{"Bearer":[]}],"summary":"Upload new ownership proof","tags":["ownership"]}},"/receipt":{"get":{"description":"Get all receipts associated with a specific user","parameters":[{"description":"Number of receipts to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_ReceiptResponseBody"}}},"description":"Receipts retrieved successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid query parameters"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Failed to retrieve receipts"}},"summary":"Retrieve receipts by user ID","tags":["receipt"]}},"/request/bydorm/{id}":{"get":{"description":"Retrieve a list of all leasing request by dormid","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}},{"description":"Number of leasing request to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_LeasingRequest"}}},"description":"Retrieve request successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format or limit parameter is incorrect or page parameter is incorrect or page exceeded"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing request not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID"}},"security":[{"Bearer":[]}],"summary":"Get all leasing request by dormid","tags":["request"]}},"/request/me":{"get":{"description":"Retrieve a list of all leasing request by userid","parameters":[{"description":"Number of dorms to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_LeasingRequest"}}},"description":"OK"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format or limit parameter is incorrect or page parameter is incorrect"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing request not found"}},"security":[{"Bearer":[]}],"summary":"Get all leasing request by userid","tags":["request"]}},"/request/{id}":{"delete":{"description":"Delete a leasing request in the database","parameters":[{"description":"LeasingRequestId","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"No Content"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized or only admin can delete a request"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing request not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or Failed to delete leasing request"}},"security":[{"Bearer":[]}],"summary":"Delete a leasing request","tags":["request"]},"post":{"description":"Add a new leasing request to the database","parameters":[{"description":"DormID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.LeasingRequestCreateRequestBody"}}},"description":"request information","required":true},"responses":{"201":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_LeasingRequest"}}},"description":"Dorm successfully created"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Dorm not found or leasing request not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or failed to save leasing request to database"}},"security":[{"Bearer":[]}],"summary":"Create a new leasing request","tags":["request"]}},"/request/{id}/approve":{"patch":{"description":"Approve a leasing request","parameters":[{"description":"LeasingRequestId","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"No Content"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Incorrect UUID format"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized or lessee cannot approve a request"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing request not found or request is not in the pending status"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or Failed to update leasing request"}},"security":[{"Bearer":[]}],"summary":"Approve a leasing request","tags":["request"]}},"/request/{id}/cancel":{"patch":{"description":"Cancel a leasing request","parameters":[{"description":"LeasingRequestId","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"No Content"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing request not found or request is not in the pending status"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized or lessor cannot cancel a request"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing request not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or Failed to update leasing request"}},"security":[{"Bearer":[]}],"summary":"Cancel a leasing request","tags":["request"]}},"/request/{id}/reject":{"patch":{"description":"Reject a leasing request","parameters":[{"description":"LeasingRequestId","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"No Content"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing request not found or request is not in the pending status"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized or lessee cannot reject a request"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing request not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Can not parse UUID or Failed to update leasing request"}},"security":[{"Bearer":[]}],"summary":"Reject a leasing request","tags":["request"]}},"/support":{"get":{"description":"Retrieve a list of all support requests.","parameters":[{"description":"Number of support requests to retrieve (default 10, max 50)","in":"query","name":"limit","schema":{"type":"integer"}},{"description":"Page number to retrieve (default 1)","in":"query","name":"page","schema":{"type":"integer"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.PaginationResponse-dto_SupportResponseBody"}}},"description":"All support requests retrieved successfully"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Could not fetch support requests"}},"security":[{"Bearer":[]}],"summary":"Get all support requests","tags":["support"]},"post":{"description":"Let a user send a message to the admin","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SupportRequestBody"}}},"description":"Support Request","required":true},"responses":{"201":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_SupportResponseBody"}}},"description":"Support request submitted successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Could not submit support request"}},"security":[{"Bearer":[]}],"summary":"Submit a support request","tags":["support"]}},"/support/{id}":{"patch":{"description":"Modifies an existing support request's status based on the given ID. The possible status are OPEN, IN-PROGRESS, and RESOLVED.","parameters":[{"description":"SupportRequestID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.UpdateStatusRequestBody"}}},"description":"Status update","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_SupportResponseBody"}}},"description":"Status updated"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid Request"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"You do not have permission to update support request status"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Support request not found"},"422":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Invalid status value"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Server failed to update support request status"}},"security":[{"Bearer":[]}],"summary":"Update a support request's status","tags":["support"]}},"/transaction":{"post":{"description":"Create a transaction","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.TransactionRequestBody"}}},"description":"Transaction request body","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_CreateTransactionResponseBody"}}},"description":"Transaction created successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"leasing history not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"cannot parse uuid or cannot delete user"}},"security":[{"Bearer":[]}],"summary":"Create a transaction","tags":["transaction"]}},"/user":{"patch":{"description":"Update user information","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.UserInformationRequestBody"}}},"description":"user information","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_UserResponse"}}},"description":"user successfully updated account information"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot update your account information"}},"security":[{"Bearer":[]}],"summary":"Update user information","tags":["user"]}},"/user/":{"delete":{"description":"Delete a user account","requestBody":{"content":{"application/json":{"schema":{"type":"object"}}}},"responses":{"204":{"description":"account successfully deleted"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"cannot parse uuid or cannot delete user"}},"security":[{"Bearer":[]}],"summary":"Delete a user account","tags":["user"]}},"/user/firstfill":{"patch":{"description":"Fill user information first time","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.UserFirstFillRequestBody"}}},"description":"user information","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_UserResponse"}}},"description":"user successfully updated account information"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot update your account information"}},"security":[{"Bearer":[]}],"summary":"Fill user information first time","tags":["user"]}},"/user/income":{"get":{"description":"Retrieve the monthly leasing income of a lessor based on leasing history","responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_LessorIncomeResponseBody"}}},"description":"Successfully retrieve income"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"User is not a lessor"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot get lessor income"}},"security":[{"Bearer":[]}],"summary":"Get monthly income for a lessor","tags":["user"]}},"/user/me":{"get":{"description":"Get user information","responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_UserResponse"}}},"description":"get user information successfully"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot get user information"}},"security":[{"Bearer":[]}],"summary":"Get user information","tags":["user"]}},"/user/newpassword":{"post":{"description":"Reset password","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ResetPasswordRequestBody"}}},"description":"token","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_TokenWithUserInformationResponseBody"}}},"description":"password reset successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot reset password"}},"summary":"Reset password","tags":["user"]}},"/user/profilePic":{"post":{"description":"Upload an profile picture for the current user, by attaching the image as a value for the key field name \"image\", as a multipart form-data","requestBody":{"content":{"multipart/form-data":{"schema":{"type":"file"}}},"description":"Profile picture image","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_ProfilePictureUploadResponseBody"}}},"description":"Profile picture updated"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"File is required"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"User not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Server failed to upload file"}},"security":[{"Bearer":[]}],"summary":"Upload user profile picture","tags":["user"]}},"/user/resend":{"post":{"description":"Re send the confirmation email","responses":{"204":{"description":"resend verification email successfully"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot verification email"}},"security":[{"Bearer":[]}],"summary":"SendConfirmationEmailAgain","tags":["user"]}},"/user/resetpassword":{"post":{"description":"Resend verification email","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ResetPasswordCreateRequestBody"}}},"description":"token","required":true},"responses":{"204":{"description":"email is sent to user successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot resend verification email"}},"summary":"Resend verification email","tags":["user"]}},"/user/studentEvidence":{"post":{"description":"Upload an image of a student ID card, by attaching the image as a value for the key field name \"image\", as a multipart form-data","requestBody":{"content":{"multipart/form-data":{"schema":{"type":"file"}}},"description":"Student ID image","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_StudentEvidenceUploadResponseBody"}}},"description":"Evidence uploaded successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"File is required"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"forbidden"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"User not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"Server failed to upload file"}},"security":[{"Bearer":[]}],"summary":"Upload an evidence for student verification","tags":["user"]}},"/user/verify":{"post":{"description":"Verify email","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.VerifyRequestBody"}}},"description":"token","required":true},"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_TokenWithUserInformationResponseBody"}}},"description":"email is verified successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is invalid"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot verify your email"}},"summary":"Verify email","tags":["user"]}},"/user/{id}":{"get":{"description":"Get User By ID","parameters":[{"description":"user id","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_UserResponse"}}},"description":"get user information successfully"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot get user information"}},"security":[{"Bearer":[]}],"summary":"GetUserByID","tags":["user"]}},"/user/{id}/studentEvidence":{"get":{"description":"Get student evidence by user id","parameters":[{"description":"userID","in":"path","name":"id","required":true,"schema":{"type":"string"}}],"responses":{"200":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.SuccessResponse-dto_StudentEvidenceUploadResponseBody"}}},"description":"Get student evidence successfully"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"invalid user id"},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"your request is unauthorized"},"403":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"unauthorized to view this evidence"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"User or evidence not found"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/dto.ErrorResponse"}}},"description":"system cannot get user's student evidence"}},"security":[{"Bearer":[]}],"summary":"Get student evidence by user id","tags":["user"]}}},
    "openapi": "3.1.0"
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Title:            "Condormhub API",
        Description:      "This is the API for the Condormhub project.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "log"

        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/PitiNarak/condormhub-backend/internal/server"
        "github.com/PitiNarak/condormhub-backend/pkg/email"
        "github.com/PitiNarak/condormhub-backend/pkg/jwt"
        "github.com/PitiNarak/condormhub-backend/pkg/redis"
        "github.com/PitiNarak/condormhub-backend/pkg/storage"
        "github.com/PitiNarak/condormhub-backend/pkg/stripe"
        "github.com/caarlos0/env/v11"
        "github.com/joho/godotenv"
)

type AppConfig struct {
        SMTP         email.SMTPConfig `envPrefix:"SMTP_"`
        JWT          jwt.JWTConfig    `envPrefix:"JWT_"`
        Server       server.Config    `envPrefix:"SERVER_"`
        Database     database.Config  `envPrefix:"DB_"`
        Storage      storage.Config   `envPrefix:"STORAGE_"`
        StripeConfig stripe.Config    `envPrefix:"STRIPE_"`
        Redis        redis.Config     `envPrefix:"REDIS_"`
}

// Load configs from .env file
func Load() *AppConfig <span class="cov0" title="0">{
        config := &amp;AppConfig{}

        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Unable to load .env file: %s", err)
        }</span>

        <span class="cov0" title="0">if err := env.Parse(config); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Unable to parse env vars: %s", err)
        }</span>

        <span class="cov0" title="0">return config</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package domain

import (
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
)

type ContractStatus string

const (
        Waiting   ContractStatus = "WAITING"
        Signed    ContractStatus = "SIGNED"
        Cancelled ContractStatus = "CANCELLED"
)

type Contract struct {
        ID           uuid.UUID      `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        CreateAt     time.Time      `gorm:"autoCreateTime"`
        LesseeID     uuid.UUID      `gorm:"type:uuid;not null"`
        Lessee       User           `gorm:"foreignKey:LesseeID;references:ID"`
        DormID       uuid.UUID      `gorm:"type:uuid;not null"`
        Dorm         Dorm           `gorm:"foreignKey:DormID;references:ID"`
        LessorStatus ContractStatus `gorm:"default:WAITING"`
        LesseeStatus ContractStatus `gorm:"default:WAITING"`
        Status       ContractStatus `gorm:"default:WAITING"`
}

func (ct *Contract) ToDTO() dto.ContractResponseBody <span class="cov0" title="0">{
        return dto.ContractResponseBody{
                ID:             ct.ID,
                Lessee:         ct.Lessee.ToDTO(),
                Dorm:           ct.Dorm.ToDTO(),
                LessorStatus:   dto.ContractStatus(ct.LessorStatus),
                LesseeStatus:   dto.ContractStatus(ct.LesseeStatus),
                ContractStatus: dto.ContractStatus(ct.Status),
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package domain

import (
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type Dorm struct {
        ID          uuid.UUID      `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        CreateAt    time.Time      `gorm:"autoCreateTime"`
        UpdateAt    time.Time      `gorm:"autoUpdateTime"`
        DeletedAt   gorm.DeletedAt `gorm:"index"`
        Name        string         `validate:"required"`
        OwnerID     uuid.UUID      `validate:"required"`
        Owner       User
        Size        float64 `validate:"required,gt=0"`
        Bedrooms    int     `validate:"required,gte=0"`
        Bathrooms   int     `validate:"required,gte=0"`
        Address     Address `gorm:"embedded" validate:"required"`
        Price       float64 `validate:"required,gt=0"`
        Rating      float64 `gorm:"default:0" validate:"gte=0,lte=5"`
        Description string  `gorm:"type:text"`
        Images      []DormImage
}

type Address struct {
        District    string `validate:"required"`
        Subdistrict string `validate:"required"`
        Province    string `validate:"required"`
        Zipcode     string `validate:"required,numeric,len=5"`
}

func (d *Dorm) ToDTO() dto.DormResponseBody <span class="cov0" title="0">{
        return dto.DormResponseBody{
                ID:          d.ID,
                CreateAt:    d.CreateAt,
                UpdateAt:    d.UpdateAt,
                Name:        d.Name,
                Owner:       d.Owner.ToDTO(),
                Size:        d.Size,
                Bedrooms:    d.Bedrooms,
                Bathrooms:   d.Bathrooms,
                Address:     d.Address.ToDTO(),
                Price:       d.Price,
                Rating:      d.Rating,
                Description: d.Description,
        }
}</span>

func (a *Address) ToDTO() dto.Address <span class="cov0" title="0">{
        return dto.Address{
                District:    a.District,
                Subdistrict: a.Subdistrict,
                Province:    a.Province,
                Zipcode:     a.Zipcode,
        }
}</span>

type DormImage struct {
        ID       uuid.UUID `json:"id" gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        CreateAt time.Time `json:"createAt" gorm:"autoCreateTime"`
        DormID   uuid.UUID `gorm:"type:uuid;not null"`
        ImageKey string    `gorm:"type:text;not null"`
}

func updateDormsOwnedCount(tx *gorm.DB, lessorID uuid.UUID) error <span class="cov0" title="0">{
        var count int64
        if err := tx.Model(&amp;Dorm{}).Where("owner_id = ?", lessorID).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := tx.Model(&amp;User{}).Where("id = ?", lessorID).Update("dorms_owned", count).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (d *Dorm) AfterCreate(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        return updateDormsOwnedCount(tx, d.OwnerID)
}</span>

func (d *Dorm) AfterDelete(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        return updateDormsOwnedCount(tx, d.OwnerID)
}</span>

func (d *Dorm) BeforeDelete(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        // Mark Pending leasing request as Rejected if the dorm related is deleted
        err = tx.Model(&amp;LeasingRequest{}).Where("dorm_id = ? AND status = ?", d.ID, RequestPending).Update("status", RequestRejected).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Mark Waiting Contract as Canceled if the dorm related is deleted
        <span class="cov0" title="0">err = tx.Model(&amp;Contract{}).Where("dorm_id = ? AND status = ?", d.ID, Waiting).Update("status", Cancelled).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Soft delete Ownership proof when deleting dorm
        <span class="cov0" title="0">err = tx.Model(&amp;OwnershipProof{}).Where("dorm_id = ?", d.ID).Delete(&amp;OwnershipProof{}).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package domain

import (
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type LeasingHistory struct {
        ID         uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        DormID     uuid.UUID `gorm:"type:uuid;not null"`
        Dorm       Dorm      `gorm:"foreignKey:DormID;references:ID"`
        LesseeID   uuid.UUID `gorm:"type:uuid;not null"`
        Lessee     User      `gorm:"foreignKey:LesseeID;references:ID"`
        Orders     []Order   `gorm:"foreignKey:LeasingHistoryID"`
        Start      time.Time
        End        time.Time `gorm:"default:null"`
        Price      float64
        ReviewFlag bool
        Review     *Review        `gorm:"embedded"`
        Images     []ReviewImage  `gorm:"foreignKey:HistoryID"` // Link to ReviewImage
        DeletedAt  gorm.DeletedAt `gorm:"index"`
}

func (l *LeasingHistory) ToDTO(urls []string) dto.LeasingHistory <span class="cov0" title="0">{
        orders := make([]dto.OrderResponseBody, len(l.Orders))
        for i, v := range l.Orders </span><span class="cov0" title="0">{
                orders[i] = v.ToDTO()
        }</span>
        <span class="cov0" title="0">var review dto.Review
        if l.ReviewFlag </span><span class="cov0" title="0">{
                review = l.Review.ToDTO(urls, l.Lessee.ToDTO())
        }</span>

        <span class="cov0" title="0">return dto.LeasingHistory{
                ID:         l.ID,
                Dorm:       l.Dorm.ToDTO(),
                Lessee:     l.Lessee.ToDTO(),
                Orders:     orders,
                Start:      l.Start,
                End:        l.End,
                Price:      l.Price,
                Review:     review,
                ReviewFlag: l.ReviewFlag,
        }</span>
}

type Review struct {
        Message    string     `gorm:"default:null"`
        Rate       int        `gorm:"default:null"`
        CreateAt   *time.Time `gorm:"autoUpdateTime;default:null"`
        ReportFlag bool       `gorm:"default:false"`
}

type ReviewImage struct {
        ID        uuid.UUID `json:"id" gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        CreateAt  time.Time `json:"createAt" gorm:"autoCreateTime"`
        HistoryID uuid.UUID `gorm:"type:uuid;not null"`
        ImageKey  string    `gorm:"type:text;not null"`
}

func (r *Review) ToDTO(urls []string, reviewer dto.UserResponse) dto.Review <span class="cov0" title="0">{

        return dto.Review{
                Message:    r.Message,
                Rate:       r.Rate,
                CreateAt:   *r.CreateAt,
                Images:     urls,
                Reviewer:   reviewer,
                ReportFlag: r.ReportFlag,
        }
}</span>

func (r *Review) ToReportedReviewDTO(urls []string, reviewer dto.UserResponse, historyID uuid.UUID) dto.ReportedReview <span class="cov0" title="0">{
        return dto.ReportedReview{
                HistoryID: historyID,
                Message:   r.Message,
                Rate:      r.Rate,
                Reviewer:  reviewer,
                CreateAt:  *r.CreateAt,
                Images:    urls,
        }
}</span>

func (l *LeasingHistory) AfterUpdate(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        // Calculate the new average rating after an update to leasingHistory
        var avgRating float64
        err = tx.Model(&amp;LeasingHistory{}).Select("COALESCE(avg(rate), 0)").Where("dorm_id = ?", l.DormID).Where("review_flag = ?", true).Scan(&amp;avgRating).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update the rating field in the dorms table
        <span class="cov0" title="0">err = tx.Model(Dorm{}).Where("id = ?", l.DormID).Update("rating", avgRating).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Find the dorm the is related to the updated leasingHistory to find the lessor related
        <span class="cov0" title="0">dorm := new(Dorm)
        err = tx.First(dorm, l.DormID).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Count the amount of review a lessor has after an update to leasingHistory
        <span class="cov0" title="0">var count int64
        err = tx.Model(&amp;LeasingHistory{}).Joins("JOIN dorms ON dorms.id = leasing_histories.dorm_id").Where("dorms.owner_id = ?", dorm.OwnerID).Where("leasing_histories.review_flag = ?", true).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update the review count in the users table
        <span class="cov0" title="0">err = tx.Model(&amp;User{}).Where("id = ?", dorm.OwnerID).Update("review_count", count).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func updateDormsLeasedCount(tx *gorm.DB, lesseeID uuid.UUID) error <span class="cov0" title="0">{
        var count int64
        if err := tx.Model(&amp;LeasingHistory{}).Where("lessee_id = ?", lesseeID).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := tx.Model(&amp;User{}).Where("id = ?", lesseeID).Update("dorms_leased", count).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (l *LeasingHistory) AfterCreate(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        return updateDormsLeasedCount(tx, l.LesseeID)
}</span>

func (l *LeasingHistory) BeforeDelete(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        return tx.Model(&amp;Order{}).Where("leasing_history_id = ?", l.ID).Delete(&amp;Order{}).Error
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package domain

import (
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
)

type Status string

const (
        RequestPending  Status = "PENDING"
        RequestAccepted Status = "ACCEPT"
        RequestRejected Status = "REJECT"
        RequestCanceled Status = "CANCELED"
)

type LeasingRequest struct {
        ID       uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        Status   Status    `gorm:"default:null"`
        DormID   uuid.UUID `gorm:"type:uuid;not null"`
        Dorm     Dorm      `gorm:"foreignKey:DormID;references:ID"`
        LesseeID uuid.UUID `gorm:"type:uuid;not null"`
        Lessee   User      `gorm:"foreignKey:LesseeID;references:ID"`
        Start    time.Time `gorm:"autoCreateTime"`
        End      time.Time `gorm:"default:null"`
        Message  string
}

func (l *LeasingRequest) ToDTO() dto.LeasingRequest <span class="cov0" title="0">{
        return dto.LeasingRequest{
                ID:      l.ID,
                Status:  dto.Status(l.Status),
                Dorm:    l.Dorm.ToDTO(),
                Lessee:  l.Lessee.ToDTO(),
                Start:   l.Start,
                End:     l.End,
                Message: l.Message,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package domain

import (
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type OrderType string

const (
        InsuranceOrderType   OrderType = "insurance"
        MonthlyBillOrderType OrderType = "monthly_bill"
)

type Order struct {
        ID                uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        CreateAt          time.Time `gorm:"autoCreateTime"`
        UpdateAt          time.Time `gorm:"autoUpdateTime"`
        Type              OrderType
        Price             int64
        Transactions      []*Transaction `gorm:"foreignKey:OrderID"`
        PaidTransaction   *Transaction   `gorm:"foreignKey:OrderID;default:null"`
        PaidTransactionID string         `gorm:"default:null"`
        LeasingHistory    LeasingHistory `gorm:"foreignKey:LeasingHistoryID"`
        LeasingHistoryID  uuid.UUID
        DeletedAt         gorm.DeletedAt `gorm:"index"`
}

func (o *Order) ToDTO() dto.OrderResponseBody <span class="cov0" title="0">{
        return dto.OrderResponseBody{
                ID:              o.ID,
                Type:            string(o.Type),
                Price:           o.Price,
                PaidTransaction: o.PaidTransaction.ToDTO(),
        }
}</span>

func (o *Order) BeforeDelete(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        return tx.Model(&amp;Transaction{}).Where("order_id = ?", o.ID).Delete(&amp;Transaction{}).Error
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package domain

import (
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
)

type Receipt struct {
        ID            uuid.UUID   `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        CreateAt      time.Time   `gorm:"autoCreateTime"`
        OwnerID       uuid.UUID   `gorm:"type:uuid;not null"`
        Owner         User        `gorm:"foreignKey:OwnerID;references:ID"`
        TransactionID string      `gorm:"not null"`
        Transaction   Transaction `gorm:"foreignKey:TransactionID;references:ID"`
        FileKey       string
}

func (r *Receipt) ToDTO(url string) dto.ReceiptResponseBody <span class="cov0" title="0">{
        return dto.ReceiptResponseBody{
                ID:          r.ID,
                Owner:       r.Owner.ToDTO(),
                Transaction: r.Transaction.ToDTO(),
                Url:         url,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
)

type SampleLog struct {
        Id       uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4();primaryKey" json:"id"`
        Message  string    `json:"message" validate:"required"`
        CreateAt time.Time `gorm:"autoCreateTime" json:"create_at"`
        UpdateAt time.Time `gorm:"autoUpdateTime" json:"update_at"`
}

func NewSampleLog(id uuid.UUID, message string) *SampleLog <span class="cov0" title="0">{
        return &amp;SampleLog{
                Id:      id,
                Message: message,
        }
}</span>

func (l *SampleLog) GetId() uuid.UUID <span class="cov0" title="0">{
        return l.Id
}</span>

func (l *SampleLog) GetMessage() string <span class="cov0" title="0">{
        return l.Message
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package domain

import (
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
)

type SupportStatus string

const (
        ProblemOpen       SupportStatus = "OPEN"
        ProblemInProgress SupportStatus = "IN-PROGRESS"
        ProblemResolved   SupportStatus = "RESOLVED"
)

type SupportRequest struct {
        ID       uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        CreateAt time.Time `gorm:"autoCreateTime"`
        UpdateAt time.Time `gorm:"autoUpdateTime"`
        UserID   uuid.UUID
        Message  string        `gorn:"type:text;not null"`
        Status   SupportStatus `gorm:"default:'OPEN'"`
}

func (s *SupportRequest) ToDTO() dto.SupportResponseBody <span class="cov0" title="0">{
        return dto.SupportResponseBody{
                ID:       s.ID,
                CreateAt: s.CreateAt,
                UpdateAt: s.UpdateAt,
                UserID:   s.UserID,
                Message:  s.Message,
                Status:   string(s.Status),
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package domain

import (
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type CheckoutStatus string

const (
        StatusOpen     CheckoutStatus = "open"
        StatusComplete CheckoutStatus = "complete"
        StatusExpired  CheckoutStatus = "expired"
)

type Transaction struct {
        ID            string         `gorm:"primaryKey"`
        SessionStatus CheckoutStatus `gorm:"default:open"`
        CreateAt      time.Time      `gorm:"autoCreateTime"`
        UpdateAt      time.Time      `gorm:"autoUpdateTime"`
        Price         int64
        Order         Order `gorm:"foreignKey:OrderID"`
        OrderID       uuid.UUID
        DeletedAt     gorm.DeletedAt `gorm:"index"`
}

func (t *Transaction) ToDTO() dto.TransactionResponse <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return dto.TransactionResponse{}
        }</span>
        <span class="cov0" title="0">return dto.TransactionResponse{
                ID:            t.ID,
                SessionStatus: string(t.SessionStatus),
                CreateAt:      t.CreateAt,
                UpdateAt:      t.UpdateAt,
                Price:         t.Price,
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package domain

import (
        "database/sql/driver"
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type Role string

const (
        AdminRole  Role = "ADMIN"
        LesseeRole Role = "LESSEE"
        LessorRole Role = "LESSOR"
)

type Lifestyle string

var validLifestyles = []Lifestyle{
        "Active",
        "Creative",
        "Social",
        "Relaxed",

        "Football",
        "Basketball",
        "Tennis",
        "Swimming",
        "Running",
        "Cycling",
        "Badminton",
        "Yoga",
        "Gym &amp; Fitness",

        "Music",
        "Dancing",
        "Photography",
        "Painting",
        "Gaming",
        "Reading",
        "Writing",
        "DIY &amp; Crafting",
        "Cooking",

        "Extrovert",
        "Introvert",
        "Night Owl",
        "Early Bird",

        "Traveler",
        "Backpacker",
        "Nature Lover",
        "Camping",
        "Beach Lover",

        "Dog Lover",
        "Cat Lover",

        "Freelancer",
        "Entrepreneur",
        "Office Worker",
        "Remote Worker",
        "Student",
        "Self-Employed",
}

// IsValid checks if the lifestyle value is in the valid slice.
func (l Lifestyle) IsValid() bool <span class="cov0" title="0">{
        for _, validLifestyle := range validLifestyles </span><span class="cov0" title="0">{
                if l == validLifestyle </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

type LifestyleArray []Lifestyle

// Scan converts PostgreSQL data to LifestyleArray
func (l *LifestyleArray) Scan(value interface{}) error <span class="cov0" title="0">{
        // Handle the empty array case from PostgreSQL ("{}")
        if value == "{}" </span><span class="cov0" title="0">{
                *l = []Lifestyle{}
                return nil
        }</span>

        // Handle the case where the value is a string (PostgreSQL array format)
        <span class="cov0" title="0">str, ok := value.(string)
        if ok </span><span class="cov0" title="0">{
                // Remove surrounding curly braces
                str = str[1 : len(str)-1] // Removes `{}`

                // Use regex to correctly split elements handling quotes
                re := regexp.MustCompile(`"([^"]*)"|([^,]+)`)
                matches := re.FindAllStringSubmatch(str, -1)

                var lifestyles []Lifestyle
                for _, match := range matches </span><span class="cov0" title="0">{
                        if match[1] != "" </span><span class="cov0" title="0">{
                                lifestyles = append(lifestyles, Lifestyle(match[1])) // Remove surrounding quotes
                        }</span> else<span class="cov0" title="0"> {
                                lifestyles = append(lifestyles, Lifestyle(match[2]))
                        }</span>
                }

                <span class="cov0" title="0">*l = lifestyles
                return nil</span>
        }

        // Handle the case where the value is a byte slice (PostgreSQL array format)
        <span class="cov0" title="0">byteArray, ok := value.([]byte)
        if ok </span><span class="cov0" title="0">{
                // Convert byte array to string and process similarly
                str := string(byteArray)
                str = str[1 : len(str)-1] // Removing the {} characters
                elements := strings.Split(str, ",")
                var lifestyles []Lifestyle
                for _, elem := range elements </span><span class="cov0" title="0">{
                        elem = strings.TrimSpace(elem)
                        lifestyles = append(lifestyles, Lifestyle(elem))
                }</span>
                <span class="cov0" title="0">*l = lifestyles
                return nil</span>
        }

        // If the value is neither a string nor a byte slice, return an error
        <span class="cov0" title="0">return fmt.Errorf("failed to scan LifestyleArray: %v", value)</span>
}

// Value converts LifestyleArray to database format
func (l LifestyleArray) Value() (driver.Value, error) <span class="cov0" title="0">{
        if len(l) == 0 </span><span class="cov0" title="0">{
                return "{}", nil // Empty PostgreSQL array
        }</span>

        // jsonData, err := json.Marshal(l)
        // fmt.Println(jsonData)

        <span class="cov0" title="0">strLifestyles := make([]string, len(l))
        for i, lifestyle := range l </span><span class="cov0" title="0">{
                strLifestyles[i] = string(lifestyle)
        }</span>

        // Return the PostgreSQL array format without any extra string ("Lifestyles: ")
        <span class="cov0" title="0">return "{" + strings.Join(strLifestyles, ",") + "}", nil</span>

        // if err != nil {
        //         return nil, err
        // }
        // return string(jsonData), nil
}

type VerificationStatus string

const (
        StatusPending  VerificationStatus = "PENDING"
        StatusVerified VerificationStatus = "VERIFIED"
        StatusRejected VerificationStatus = "REJECTED"
)

type User struct {
        ID                 uuid.UUID      `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        CreateAt           time.Time      `gorm:"autoCreateTime"`
        UpdateAt           time.Time      `gorm:"autoUpdateTime"`
        DeletedAt          gorm.DeletedAt `gorm:"index"`
        Username           string         `gorm:"unique" validate:"required"`
        Password           string         `validate:"required,min=8"`
        Email              string         `gorm:"unique" validate:"required,email"`
        Firstname          string
        Lastname           string
        NationalID         string
        Gender             string
        BirthDate          time.Time      `gorm:"type:DATE;default:null"`
        IsVerified         bool           `gorm:"default:false"`
        Role               Role           `gorm:"default:null"`
        FilledPersonalInfo bool           `gorm:"default:false"`
        Lifestyles         LifestyleArray `validate:"lifestyle" gorm:"type:lifestyle_tag[]"`
        PhoneNumber        string
        StudentEvidence    string
        IsStudentVerified  VerificationStatus
        ProfilePicKey      string
        ReviewCount        int64 `gorm:"default:0"`
        DormsOwned         int64 `gorm:"default:0"`
        DormsLeased        int64 `gorm:"default:0"`
        Banned             bool  `gorm:"default:false"`
}

func (u *User) ToDTO() dto.UserResponse <span class="cov0" title="0">{
        lifestyles := make([]string, len(u.Lifestyles))
        for i, v := range u.Lifestyles </span><span class="cov0" title="0">{
                lifestyles[i] = string(v)
        }</span>
        <span class="cov0" title="0">return dto.UserResponse{
                ID:                 u.ID,
                CreateAt:           u.CreateAt,
                Username:           u.Username,
                Email:              u.Email,
                Firstname:          u.Firstname,
                Lastname:           u.Lastname,
                Gender:             u.Gender,
                BirthDate:          u.BirthDate,
                IsVerified:         u.IsVerified,
                Role:               string(u.Role),
                FilledPersonalInfo: u.FilledPersonalInfo,
                Lifestyles:         lifestyles,
                PhoneNumber:        u.PhoneNumber,
                IsStudentVerified:  string(u.IsStudentVerified),
                ReviewCount:        u.ReviewCount,
                DormsOwned:         u.DormsOwned,
                DormsLeased:        u.DormsLeased,
                Banned:             u.Banned,
        }</span>
}

func (u *User) BeforeDelete(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        // Soft delete dorm owned by lessor when deleting their account
        err = tx.Model(&amp;Dorm{}).Where("owner_id = ?", u.ID).Delete(&amp;Dorm{}).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Mark Pending leasing request as Canceled if a lessee delete their account
        <span class="cov0" title="0">err = tx.Model(&amp;LeasingRequest{}).Where("lessee_id = ? AND status = ?", u.ID, RequestPending).Update("status", RequestCanceled).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Mark Waiting Contract as Canceled if a lessee delete their account
        <span class="cov0" title="0">err = tx.Model(&amp;Contract{}).Where("lessee_id = ? AND status = ?", u.ID, Waiting).Update("status", Cancelled).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package services

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type ContractService struct {
        contractRepo          ports.ContractRepository
        userRepo              ports.UserRepository
        dormRepo              ports.DormRepository
        leasingHistoryService ports.LeasingHistoryService
}

func NewContractService(contractRepo ports.ContractRepository, userRepo ports.UserRepository, dormRepo ports.DormRepository, leasingHistoryService ports.LeasingHistoryService) ports.ContractService <span class="cov0" title="0">{
        return &amp;ContractService{
                contractRepo:          contractRepo,
                userRepo:              userRepo,
                dormRepo:              dormRepo,
                leasingHistoryService: leasingHistoryService,
        }
}</span>

func (ct *ContractService) DeleteContract(contractID uuid.UUID) error <span class="cov0" title="0">{
        return ct.contractRepo.Delete(contractID)
}</span>

func (ct *ContractService) GetContractByContractID(contractID uuid.UUID) (*domain.Contract, error) <span class="cov0" title="0">{
        return ct.contractRepo.GetContractByContractID(contractID)
}</span>

func (ct *ContractService) GetByUserID(userID uuid.UUID, limit, page int) (*[]domain.Contract, int, int, error) <span class="cov0" title="0">{
        user, userErr := ct.userRepo.GetUserByID(userID)
        if userErr != nil </span><span class="cov0" title="0">{
                return nil, 0, 0, userErr
        }</span>
        <span class="cov0" title="0">if user == nil || user.Role == "" </span><span class="cov0" title="0">{
                return nil, 0, 0, apperror.BadRequestError(errors.New("invalid user"), "user not found or role is missing")
        }</span>
        <span class="cov0" title="0">if user.Role == domain.AdminRole </span><span class="cov0" title="0">{
                return nil, 0, 0, apperror.BadRequestError(errors.New("invalid user"), "role mismatch")
        }</span>
        <span class="cov0" title="0">return ct.getContractsByRole(user.Role, userID, limit, page)</span>
}
func (ct *ContractService) getContractsByRole(role domain.Role, userID uuid.UUID, limit, page int) (*[]domain.Contract, int, int, error) <span class="cov0" title="0">{
        if role == domain.LessorRole </span><span class="cov0" title="0">{
                return ct.contractRepo.GetContractByLessorID(userID, limit, page)
        }</span>
        <span class="cov0" title="0">return ct.contractRepo.GetContractByLesseeID(userID, limit, page)</span>
}

func (ct *ContractService) GetByDormID(dormID uuid.UUID, limit, page int) (*[]domain.Contract, int, int, error) <span class="cov0" title="0">{
        contracts, totalPage, totalRows, err := ct.contractRepo.GetContractByLessorID(dormID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, totalPage, totalRows, err
        }</span>
        <span class="cov0" title="0">return contracts, totalPage, totalRows, nil</span>
}

func (ct *ContractService) UpdateStatus(contractID uuid.UUID, status domain.ContractStatus, userID uuid.UUID) error <span class="cov0" title="0">{
        //check valid lessor ID

        user, userErr := ct.userRepo.GetUserByID(userID)
        if userErr != nil </span><span class="cov0" title="0">{
                return userErr
        }</span>
        <span class="cov0" title="0">if user == nil || user.Role == "" </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("invalid user"), "user not found or role is missing")
        }</span>
        <span class="cov0" title="0">if user.Role == domain.AdminRole </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("invalid user"), "role mismatch")
        }</span>

        <span class="cov0" title="0">if err := ct.contractRepo.UpdateStatus(contractID, status, &amp;user.Role); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">contract, err := ct.contractRepo.GetContractByContractID(contractID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if contract.LesseeStatus == domain.Signed &amp;&amp; contract.LessorStatus == domain.Signed </span><span class="cov0" title="0">{
                if err := ct.contractRepo.UpdateStatus(contractID, domain.Signed, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := ct.leasingHistoryService.Create(contract.LesseeID, contract.DormID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if contract.LesseeStatus == domain.Cancelled || contract.LessorStatus == domain.Cancelled </span><span class="cov0" title="0">{
                if err := ct.contractRepo.UpdateStatus(contractID, domain.Cancelled, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package services

import (
        "context"
        "errors"
        "fmt"
        "io"
        "strings"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/PitiNarak/condormhub-backend/pkg/storage"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type DormService struct {
        dormRepo ports.DormRepository
        storage  *storage.Storage
}

func NewDormService(repo ports.DormRepository, storage *storage.Storage) ports.DormService <span class="cov8" title="1">{
        return &amp;DormService{dormRepo: repo, storage: storage}
}</span>

func checkPermission(ownerID uuid.UUID, userID uuid.UUID, isAdmin bool) error <span class="cov0" title="0">{
        if ownerID != userID &amp;&amp; !isAdmin </span><span class="cov0" title="0">{
                return errors.New("unauthorized action")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *DormService) GetImageUrl(dormImage []domain.DormImage) []string <span class="cov0" title="0">{
        urls := make([]string, len(dormImage))
        for i, v := range dormImage </span><span class="cov0" title="0">{
                urls[i] = s.storage.GetPublicUrl(v.ImageKey)
        }</span>
        <span class="cov0" title="0">return urls</span>
}

func (s *DormService) Create(userRole domain.Role, dorm *domain.Dorm) error <span class="cov8" title="1">{
        if userRole != domain.AdminRole &amp;&amp; userRole != domain.LessorRole </span><span class="cov8" title="1">{
                return apperror.ForbiddenError(errors.New("unauthorized action"), "You do not have permission to create a dorm")
        }</span>
        <span class="cov8" title="1">return s.dormRepo.Create(dorm)</span>
}

func (s *DormService) GetAll(
        limit int, page int,
        search string,
        minPrice int, maxPrice int,
        district string,
        subdistrict string,
        province string,
        zipcode string,
) ([]dto.DormResponseBody, int, int, error) <span class="cov0" title="0">{
        dorms, totalPages, totalRows, err := s.dormRepo.GetAll(limit, page, search, minPrice, maxPrice, district, subdistrict, province, zipcode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, totalPages, totalRows, err
        }</span>
        <span class="cov0" title="0">resData := make([]dto.DormResponseBody, len(dorms))
        for i, v := range dorms </span><span class="cov0" title="0">{
                resData[i] = v.ToDTO()
                resData[i].Images = s.GetImageUrl(v.Images)
        }</span>
        <span class="cov0" title="0">return resData, totalPages, totalRows, nil</span>
}

func (s *DormService) GetByID(id uuid.UUID) (*dto.DormResponseBody, error) <span class="cov0" title="0">{
        dorm, err := s.dormRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">resData := dorm.ToDTO()
        resData.Images = s.GetImageUrl(dorm.Images)
        return &amp;resData, nil</span>
}

func (s *DormService) Update(userID uuid.UUID, isAdmin bool, dormID uuid.UUID, updateData *dto.DormUpdateRequestBody) (*dto.DormResponseBody, error) <span class="cov0" title="0">{
        dorm, err := s.dormRepo.GetByID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err = checkPermission(dorm.OwnerID, userID, isAdmin); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ForbiddenError(err, "You do not have permission to update this dorm")
        }</span>

        <span class="cov0" title="0">if err := s.dormRepo.Update(dormID, *updateData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GetByID(dormID)</span>
}

func (s *DormService) Delete(ctx context.Context, userID uuid.UUID, isAdmin bool, dormID uuid.UUID) error <span class="cov0" title="0">{
        dorm, err := s.dormRepo.GetByID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := checkPermission(dorm.OwnerID, userID, isAdmin); err != nil </span><span class="cov0" title="0">{
                return apperror.ForbiddenError(err, "You do not have permission to delete this dorm")
        }</span>

        <span class="cov0" title="0">if len(dorm.Images) &gt; 0 </span><span class="cov0" title="0">{
                for _, image := range dorm.Images </span><span class="cov0" title="0">{
                        err = s.storage.DeleteFile(ctx, image.ImageKey, storage.PublicBucket)
                        if err != nil </span><span class="cov0" title="0">{
                                return apperror.InternalServerError(err, "Failed to delete images")
                        }</span>
                }
        }

        <span class="cov0" title="0">return s.dormRepo.Delete(*dorm)</span>
}

func (s *DormService) UploadDormImage(ctx context.Context, dormID uuid.UUID, filename string, contentType string, fileData io.Reader, userID uuid.UUID, isAdmin bool) (string, error) <span class="cov0" title="0">{
        dorm, err := s.dormRepo.GetByID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if err = checkPermission(dorm.OwnerID, userID, isAdmin); err != nil </span><span class="cov0" title="0">{
                return "", apperror.ForbiddenError(err, "You do not have permission to upload image to this dorm")
        }</span>

        <span class="cov0" title="0">filename = strings.ReplaceAll(filename, " ", "-")
        uuid := uuid.New().String()
        fileKey := fmt.Sprintf("dorms/%s-%s", uuid, filename)

        err = s.storage.UploadFile(ctx, fileKey, contentType, fileData, storage.PublicBucket)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "error uploading file")
        }</span>

        <span class="cov0" title="0">dormImage := &amp;domain.DormImage{DormID: dormID, ImageKey: fileKey}
        if err = s.dormRepo.SaveDormImage(dormImage); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">url := s.storage.GetPublicUrl(fileKey)

        return url, nil</span>
}

func (s *DormService) GetByOwnerID(ownerID uuid.UUID, limit int, page int) ([]dto.DormResponseBody, int, int, error) <span class="cov0" title="0">{
        dorms, totalPages, totalRows, err := s.dormRepo.GetByOwnerID(ownerID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, totalPages, totalRows, err
        }</span>
        <span class="cov0" title="0">resData := make([]dto.DormResponseBody, len(dorms))
        for i, v := range dorms </span><span class="cov0" title="0">{
                resData[i] = v.ToDTO()
                resData[i].Images = s.GetImageUrl(v.Images)
        }</span>
        <span class="cov0" title="0">return resData, totalPages, totalRows, nil</span>
}

func (s *DormService) DeleteImageByURL(ctx context.Context, imageURL string, userID uuid.UUID, isAdmin bool) error <span class="cov0" title="0">{
        imageKey, err := s.storage.GetFileKeyFromPublicUrl(imageURL)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to parse URL")
        }</span>

        <span class="cov0" title="0">dormImage, err := s.dormRepo.GetImageByKey(imageKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dorm, err := s.dormRepo.GetByID(dormImage.DormID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := checkPermission(dorm.OwnerID, userID, isAdmin); err != nil </span><span class="cov0" title="0">{
                return apperror.ForbiddenError(err, "You do not have permission to delete this dorm image")
        }</span>

        <span class="cov0" title="0">err = s.storage.DeleteFile(ctx, imageKey, storage.PublicBucket)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to delete images")
        }</span>

        <span class="cov0" title="0">return s.dormRepo.DeleteImageByKey(imageKey)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package services

import (
        "context"
        "errors"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/pkg/storage"
        "github.com/PitiNarak/condormhub-backend/pkg/utils"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type LeasingHistoryService struct {
        historyRepo ports.LeasingHistoryRepository
        dormRepo    ports.DormRepository
        storage     *storage.Storage
}

func NewLeasingHistoryService(historyRepo ports.LeasingHistoryRepository, dormRepo ports.DormRepository, storage *storage.Storage) ports.LeasingHistoryService <span class="cov0" title="0">{
        return &amp;LeasingHistoryService{historyRepo: historyRepo, dormRepo: dormRepo, storage: storage}
}</span>

func (s *LeasingHistoryService) GetImageUrl(reviewImage []domain.ReviewImage) []string <span class="cov0" title="0">{
        urls := make([]string, len(reviewImage))
        for i, v := range reviewImage </span><span class="cov0" title="0">{
                urls[i] = s.storage.GetPublicUrl(v.ImageKey)
        }</span>
        <span class="cov0" title="0">return urls</span>
}

func (s *LeasingHistoryService) Create(userID uuid.UUID, dormID uuid.UUID) (*domain.LeasingHistory, error) <span class="cov0" title="0">{
        _, err := s.dormRepo.GetByID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;domain.LeasingHistory{}, err
        }</span>
        <span class="cov0" title="0">createTime := time.Now()
        dorm, err := s.dormRepo.GetByID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;domain.LeasingHistory{}, err
        }</span>
        <span class="cov0" title="0">leasingHistory := &amp;domain.LeasingHistory{DormID: dormID, LesseeID: userID, Start: createTime, Price: dorm.Price}
        err = s.historyRepo.Create(leasingHistory)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;domain.LeasingHistory{}, err
        }</span>
        <span class="cov0" title="0">leasingHistory, err = s.historyRepo.GetByID(leasingHistory.ID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;domain.LeasingHistory{}, err
        }</span>
        <span class="cov0" title="0">return leasingHistory, nil</span>
}

func (s *LeasingHistoryService) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        err := s.historyRepo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *LeasingHistoryService) GetByID(id uuid.UUID) (*domain.LeasingHistory, error) <span class="cov0" title="0">{
        leasingHistory, err := s.historyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return leasingHistory, nil</span>
}

func (s *LeasingHistoryService) GetByUserID(id uuid.UUID, limit, page int) ([]domain.LeasingHistory, int, int, error) <span class="cov0" title="0">{
        leasingHistory, totalPage, totalRows, err := s.historyRepo.GetByUserID(id, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, totalPage, totalRows, err
        }</span>
        <span class="cov0" title="0">return leasingHistory, totalPage, totalRows, nil</span>
}
func (s *LeasingHistoryService) GetByDormID(id uuid.UUID, limit, page int) ([]domain.LeasingHistory, int, int, error) <span class="cov0" title="0">{
        leasingHistory, totalPage, totalRows, err := s.historyRepo.GetByDormID(id, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, totalPage, totalRows, err
        }</span>
        <span class="cov0" title="0">return leasingHistory, totalPage, totalRows, nil</span>
}

func (s *LeasingHistoryService) SetEndTimestamp(id uuid.UUID) error <span class="cov0" title="0">{
        leasingHistory, err := s.historyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">leasingHistory.End = time.Now()
        err = s.historyRepo.Update(leasingHistory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *LeasingHistoryService) CreateReview(user *domain.User, id uuid.UUID, Message string, Rate int) (*domain.Review, error) <span class="cov0" title="0">{
        history, err := s.historyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = utils.ValidateUserForReview(user, history, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">review := domain.Review{
                Message: Message,
                Rate:    Rate,
        }
        history.Review = &amp;review
        history.ReviewFlag = true
        err = s.historyRepo.Update(history)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">history, err = s.historyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return history.Review, nil</span>
}

func (s *LeasingHistoryService) UpdateReview(user *domain.User, id uuid.UUID, Message string, Rate int) (*domain.Review, error) <span class="cov0" title="0">{
        history, err := s.historyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = utils.ValidateUserForReview(user, history, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">review := domain.Review{
                Message: Message,
                Rate:    Rate,
        }
        history.Review = &amp;review
        err = s.historyRepo.Update(history)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">history, err = s.historyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return history.Review, nil</span>
}

func (s *LeasingHistoryService) DeleteReview(user *domain.User, id uuid.UUID) error <span class="cov0" title="0">{
        history, err := s.historyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = utils.ValidateUserForReview(user, history, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">history.ReviewFlag = false
        err = s.historyRepo.DeleteReview(history)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *LeasingHistoryService) UploadReviewImage(ctx context.Context, historyID uuid.UUID, filename string, contentType string, fileData io.Reader, userID uuid.UUID, isAdmin bool) (string, error) <span class="cov0" title="0">{
        history, err := s.historyRepo.GetByID(historyID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if err = checkPermission(history.Lessee.ID, userID, isAdmin); err != nil </span><span class="cov0" title="0">{
                return "", apperror.ForbiddenError(err, "You do not have permission to upload image to this dorm")
        }</span>

        <span class="cov0" title="0">filename = strings.ReplaceAll(filename, " ", "-")
        uuid := uuid.New().String()
        fileKey := fmt.Sprintf("reviews/%s-%s", uuid, filename)

        err = s.storage.UploadFile(ctx, fileKey, contentType, fileData, storage.PublicBucket)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "error uploading file")
        }</span>
        <span class="cov0" title="0">reviewImage := &amp;domain.ReviewImage{HistoryID: historyID, ImageKey: fileKey}
        if err = s.historyRepo.SaveReviewImage(reviewImage); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">url := s.storage.GetPublicUrl(fileKey)

        return url, nil</span>
}

func (s *LeasingHistoryService) DeleteImageByURL(ctx context.Context, imageURL string, userID uuid.UUID, isAdmin bool) error <span class="cov0" title="0">{
        imageKey, err := s.storage.GetFileKeyFromPublicUrl(imageURL)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to parse URL")
        }</span>

        <span class="cov0" title="0">reviewImage, err := s.historyRepo.GetImageByKey(imageKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">history, err := s.historyRepo.GetByID(reviewImage.HistoryID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := checkPermission(history.Lessee.ID, userID, isAdmin); err != nil </span><span class="cov0" title="0">{
                return apperror.ForbiddenError(err, "You do not have permission to delete this review image")
        }</span>

        <span class="cov0" title="0">err = s.storage.DeleteFile(ctx, imageKey, storage.PublicBucket)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to delete images")
        }</span>

        <span class="cov0" title="0">return s.historyRepo.DeleteImageByKey(imageKey)</span>
}

func (s *LeasingHistoryService) GetReportedReviews(limit int, page int) ([]domain.LeasingHistory, int, int, error) <span class="cov0" title="0">{
        return s.historyRepo.GetReportedReviews(limit, page)
}</span>

func (s *LeasingHistoryService) GetReviewByDormID(id uuid.UUID, limit, page int) ([]domain.LeasingHistory, int, int, error) <span class="cov0" title="0">{
        return s.historyRepo.GetReviewByDormID(id, limit, page)
}</span>

func (s *LeasingHistoryService) ReportReview(id uuid.UUID) (*domain.LeasingHistory, error) <span class="cov0" title="0">{
        history, err := s.historyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !history.ReviewFlag </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(errors.New("review not found"), "review not found")
        }</span>
        <span class="cov0" title="0">if history.Review.ReportFlag </span><span class="cov0" title="0">{
                return nil, apperror.ConflictError(errors.New("review already reported"), "review already reported")
        }</span>
        <span class="cov0" title="0">history.Review.ReportFlag = true
        err = s.historyRepo.Update(history)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return history, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package services

import (
        "errors"
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type LeasingRequestService struct {
        requestRepo  ports.LeasingRequestRepository
        dormRepo     ports.DormRepository
        contractRepo ports.ContractRepository
}

func NewLeasingRequestService(requestRepo ports.LeasingRequestRepository, dormRepo ports.DormRepository, contractRepo ports.ContractRepository) ports.LeasingRequestService <span class="cov0" title="0">{
        return &amp;LeasingRequestService{requestRepo: requestRepo, dormRepo: dormRepo, contractRepo: contractRepo}
}</span>

func (s *LeasingRequestService) Create(leeseeID uuid.UUID, dormID uuid.UUID, message string) (*domain.LeasingRequest, error) <span class="cov0" title="0">{
        leasingRequest := &amp;domain.LeasingRequest{
                Status:   domain.RequestPending,
                DormID:   dormID,
                LesseeID: leeseeID,
                Message:  message,
        }
        err := s.requestRepo.Create(leasingRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">leasingRequest, err = s.requestRepo.GetByID(leasingRequest.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return leasingRequest, nil</span>
}
func (s *LeasingRequestService) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        err := s.requestRepo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (s *LeasingRequestService) GetByUserID(id uuid.UUID, role domain.Role, limit, page int) ([]domain.LeasingRequest, int, int, error) <span class="cov0" title="0">{
        leasingRequest, totalPage, totalRows, err := s.requestRepo.GetByUserID(id, limit, page, role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, totalPage, totalRows, err
        }</span>
        <span class="cov0" title="0">return leasingRequest, totalPage, totalRows, nil</span>
}
func (s *LeasingRequestService) Approve(id, userId uuid.UUID, isAdmin bool) error <span class="cov0" title="0">{
        leasingRequest, err := s.requestRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if leasingRequest.Status != domain.RequestPending </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("request is not in the pending status"), "request is not in the pending status")
        }</span>
        <span class="cov0" title="0">if userId != leasingRequest.Dorm.OwnerID &amp;&amp; !isAdmin </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("user is unauthorized"), "user is unauthorized")
        }</span>
        <span class="cov0" title="0">leasingRequest.End = time.Now()
        leasingRequest.Status = domain.RequestAccepted
        err = s.requestRepo.Update(leasingRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">contract := &amp;domain.Contract{LesseeID: leasingRequest.LesseeID, DormID: leasingRequest.DormID}
        err = s.contractRepo.Create(contract)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *LeasingRequestService) Reject(id, userId uuid.UUID, isAdmin bool) error <span class="cov0" title="0">{
        leasingRequest, err := s.requestRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if leasingRequest.Status != domain.RequestPending </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("request is not in the pending status"), "request is not in the pending status")
        }</span>
        <span class="cov0" title="0">if userId != leasingRequest.Dorm.OwnerID &amp;&amp; !isAdmin </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("user is unauthorized"), "user is unauthorized")
        }</span>
        <span class="cov0" title="0">leasingRequest.End = time.Now()
        leasingRequest.Status = domain.RequestRejected
        err = s.requestRepo.Update(leasingRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *LeasingRequestService) Cancel(id, userId uuid.UUID, isAdmin bool) error <span class="cov0" title="0">{
        leasingRequest, err := s.requestRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if leasingRequest.Status != domain.RequestPending </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("request is not in the pending status"), "request is not in the pending status")
        }</span>
        <span class="cov0" title="0">if userId != leasingRequest.LesseeID &amp;&amp; !isAdmin </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("user is unauthorized"), "user is unauthorized")
        }</span>
        <span class="cov0" title="0">leasingRequest.End = time.Now()
        leasingRequest.Status = domain.RequestCanceled
        err = s.requestRepo.Update(leasingRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *LeasingRequestService) GetByDormID(id uuid.UUID, limit, page int) ([]domain.LeasingRequest, int, int, error) <span class="cov0" title="0">{
        leasingRequest, totalPage, totalRows, err := s.requestRepo.GetByDormID(id, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, totalPage, totalRows, err
        }</span>
        <span class="cov0" title="0">return leasingRequest, totalPage, totalRows, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type OrderService struct {
        orderRepository          ports.OrderRepository
        leasingHistoryRepository ports.LeasingHistoryRepository
}

func NewOrderService(orderRepository ports.OrderRepository, leasingHistoryRepository ports.LeasingHistoryRepository) ports.OrderService <span class="cov0" title="0">{
        return &amp;OrderService{orderRepository: orderRepository, leasingHistoryRepository: leasingHistoryRepository}
}</span>

func (s *OrderService) CreateOrder(leasingHistoryID uuid.UUID) (*domain.Order, error) <span class="cov0" title="0">{
        leasingHistory, err := s.leasingHistoryRepository.GetByID(leasingHistoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, err.Error())
        }</span>

        <span class="cov0" title="0">if !leasingHistory.End.IsZero() </span><span class="cov0" title="0">{
                return nil, apperror.BadRequestError(errors.New("leasing history has ended"), "leasing history has ended")
        }</span>

        <span class="cov0" title="0">order := &amp;domain.Order{
                LeasingHistoryID: leasingHistoryID,
                Price:            int64(leasingHistory.Dorm.Price),
                Type:             domain.MonthlyBillOrderType,
        }

        if err := s.orderRepository.Create(order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return order, nil</span>
}

func (s *OrderService) GetOrderByID(orderID uuid.UUID) (*domain.Order, error) <span class="cov0" title="0">{
        order, err := s.orderRepository.GetByID(orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return order, nil</span>
}

func (s *OrderService) GetUnpaidOrderByUserID(userID uuid.UUID, limit int, page int) ([]domain.Order, int, int, error) <span class="cov0" title="0">{
        orders, totalPage, totalRows, err := s.orderRepository.GetUnpaidByUserID(userID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, 0, err
        }</span>
        <span class="cov0" title="0">return orders, totalPage, totalRows, nil</span>
}

func (s *OrderService) UpdateOrder(order *domain.Order) error <span class="cov0" title="0">{
        return s.orderRepository.Update(order)
}</span>

func (s *OrderService) DeleteOrder(orderID uuid.UUID) error <span class="cov0" title="0">{
        return s.orderRepository.Delete(orderID)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/PitiNarak/condormhub-backend/pkg/storage"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type OwnershipProofService struct {
        ownershipProofRepo ports.OwnershipProofRepository
        userRepo           ports.UserRepository
        storage            *storage.Storage
}

func NewOwnershipProofService(ownershipProofRepo ports.OwnershipProofRepository, userRepo ports.UserRepository, storage *storage.Storage) ports.OwnershipProofService <span class="cov0" title="0">{
        return &amp;OwnershipProofService{
                ownershipProofRepo: ownershipProofRepo,
                userRepo:           userRepo,
                storage:            storage,
        }
}</span>

func (o *OwnershipProofService) UploadFile(ctx context.Context, dormID uuid.UUID, filename string, contentType string, fileData io.Reader) (string, error) <span class="cov0" title="0">{

        filename = strings.ReplaceAll(filename, " ", "-")
        uuid := uuid.New().String()
        fileKey := fmt.Sprintf("ownership-proof/%s-%s", uuid, filename)

        if err := o.storage.UploadFile(ctx, fileKey, contentType, fileData, storage.PrivateBucket); err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "error uploading file")
        }</span>
        <span class="cov0" title="0">url, err := o.storage.GetSignedUrl(ctx, fileKey, time.Minute*60)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "error getting signed url")
        }</span>

        <span class="cov0" title="0">ownershipProof, err := o.ownershipProofRepo.GetByDormID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                ownershipProof := domain.OwnershipProof{DormID: dormID, FileKey: fileKey}
                if err := o.ownershipProofRepo.Create(&amp;ownershipProof); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return url, nil</span>
        }

        <span class="cov0" title="0">oldFilekey := ownershipProof.FileKey
        if err := o.storage.DeleteFile(ctx, oldFilekey, storage.PrivateBucket); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return "", apperror.InternalServerError(err, "error deleting file")</span>
        }

        <span class="cov0" title="0">if err := o.ownershipProofRepo.UpdateDocument(dormID, fileKey); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return url, nil</span>

}

func (o *OwnershipProofService) Delete(ctx context.Context, dormID uuid.UUID) error <span class="cov0" title="0">{
        ownershipProof, err := o.ownershipProofRepo.GetByDormID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fileKey := ownershipProof.FileKey
        if err := o.storage.DeleteFile(ctx, fileKey, storage.PrivateBucket); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "error deleting file")</span>
        }

        <span class="cov0" title="0">if err := o.ownershipProofRepo.Delete(dormID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *OwnershipProofService) GetByDormID(dormID uuid.UUID) (*domain.OwnershipProof, error) <span class="cov0" title="0">{
        ownershipProof, err := o.ownershipProofRepo.GetByDormID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ownershipProof, nil</span>
}

func (o *OwnershipProofService) UpdateStatus(dormID uuid.UUID, adminID uuid.UUID, status domain.OwnershipProofStatus) error <span class="cov0" title="0">{
        updateStatusRequestBody := new(dto.UpdateOwnerShipProofStatusRequestBody)
        updateStatusRequestBody.Status = dto.OwnershipProofStatus(status)
        updateStatusRequestBody.AdminID = adminID

        if err := o.ownershipProofRepo.UpdateStatus(dormID, updateStatusRequestBody); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *OwnershipProofService) GetUrl(ctx context.Context, dormID uuid.UUID) (string, error) <span class="cov0" title="0">{
        ownershipProof, err := o.ownershipProofRepo.GetByDormID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">fileKey := ownershipProof.FileKey
        url, err := o.storage.GetSignedUrl(ctx, fileKey, time.Minute*60)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "error getting signed url")
        }</span>

        <span class="cov0" title="0">return url, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package services

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/pkg/storage"
        "github.com/google/uuid"
        "github.com/jung-kurt/gofpdf"
        "github.com/yokeTH/go-pkg/apperror"
)

type ReceiptService struct {
        receiptRepo        ports.ReceiptRepository
        userRepo           ports.UserRepository
        transactionRepo    ports.TransactionRepository
        orderRepo          ports.OrderRepository
        leasingHistoryRepo ports.LeasingHistoryRepository
        dormRepo           ports.DormRepository
        storage            *storage.Storage
}

func NewReceiptService(receiptRepo ports.ReceiptRepository, userRepo ports.UserRepository, transactionRepo ports.TransactionRepository, orderRepo ports.OrderRepository, leasingHistoryRepo ports.LeasingHistoryRepository, dormRepo ports.DormRepository, storage *storage.Storage) ports.ReceiptService <span class="cov0" title="0">{
        return &amp;ReceiptService{
                receiptRepo:        receiptRepo,
                userRepo:           userRepo,
                transactionRepo:    transactionRepo,
                orderRepo:          orderRepo,
                leasingHistoryRepo: leasingHistoryRepo,
                dormRepo:           dormRepo,
                storage:            storage,
        }
}</span>

func (r *ReceiptService) Create(c context.Context, ownerID uuid.UUID, transaction domain.Transaction) error <span class="cov0" title="0">{

        if err := r.validateTransaction(transaction); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">buff, buffErr := r.generatePDF(ownerID, transaction)
        if buffErr != nil </span><span class="cov0" title="0">{
                return buffErr
        }</span>

        <span class="cov0" title="0">fileKey, saveErr := r.saveFile(c, buff, transaction.ID)
        if saveErr != nil </span><span class="cov0" title="0">{
                return saveErr
        }</span>

        <span class="cov0" title="0">receipt := &amp;domain.Receipt{
                OwnerID:       ownerID,
                TransactionID: transaction.ID,
                FileKey:       fileKey,
        }

        if err := r.receiptRepo.Create(receipt); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func (r *ReceiptService) GetUrl(c context.Context, receipt domain.Receipt) (string, error) <span class="cov0" title="0">{
        url, err := r.storage.GetSignedUrl(c, receipt.FileKey, time.Minute*60)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "Fail to upload file to storage")
        }</span>
        <span class="cov0" title="0">return url, nil</span>
}

func (r *ReceiptService) validateTransaction(transaction domain.Transaction) error <span class="cov0" title="0">{
        if transaction.SessionStatus != domain.StatusComplete </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("invalid transaction"), "Receive unpaid transcation")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ReceiptService) validateOwner(ownerID uuid.UUID, leasingHistory domain.LeasingHistory) error <span class="cov0" title="0">{
        if ownerID != leasingHistory.LesseeID </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("user mismatch"), "user is not an owner of this transcation")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ReceiptService) generatePDF(ownerID uuid.UUID, transaction domain.Transaction) (*bytes.Buffer, error) <span class="cov0" title="0">{
        order, err := r.orderRepo.GetByID(transaction.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">history, err := r.leasingHistoryRepo.GetByID(order.LeasingHistoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ownerErr := r.validateOwner(ownerID, *history)
        if ownerErr != nil </span><span class="cov0" title="0">{
                return nil, ownerErr
        }</span>

        <span class="cov0" title="0">dorm, err := r.dormRepo.GetByID(history.DormID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">lessor, err := r.userRepo.GetUserByID(dorm.OwnerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">lessee, err := r.userRepo.GetUserByID(ownerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pdf := gofpdf.New("P", "mm", "A4", "")
        pdf.SetFont("Arial", "", 14)
        pdf.AddPage()

        // Header
        pdf.SetXY(10, 10)
        pdf.SetFont("Arial", "B", 16)
        pdf.Cell(190, 10, "Payment Receipt")
        pdf.Ln(12)

        // Transaction Details
        pdf.SetFont("Arial", "", 12)
        pdf.Cell(40, 10, fmt.Sprintf("Transaction ID: %s", transaction.ID))
        pdf.Ln(8)
        pdf.Cell(40, 10, fmt.Sprintf("Lessee: %s %s", lessee.Firstname, lessee.Lastname))
        pdf.Ln(8)
        pdf.Cell(40, 10, fmt.Sprintf("Lessor: %s %s", lessor.Firstname, lessor.Lastname))
        pdf.Ln(8)
        pdf.Cell(40, 10, fmt.Sprintf("Dorm: %s", dorm.Name))
        pdf.Ln(8)
        pdf.Cell(40, 10, fmt.Sprintf("Amount Paid: %.2f", float64(transaction.Price)))
        pdf.Ln(8)
        pdf.Cell(40, 10, fmt.Sprintf("Issued At: %s", time.Now()))
        pdf.Ln(12)

        // Footer
        pdf.SetFont("Arial", "I", 10)
        pdf.Cell(40, 10, "Thank you for your payment!")

        // Save to a buffer
        var buf bytes.Buffer
        if err := pdf.Output(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.InternalServerError(err, "Fail to generate PDF file")
        }</span>

        <span class="cov0" title="0">return &amp;buf, nil</span>
}

func (r *ReceiptService) saveFile(c context.Context, pdfBuffer *bytes.Buffer, transactionID string) (string, error) <span class="cov0" title="0">{
        filename := fmt.Sprintf("receipt-%s.pdf", transactionID)
        filename = strings.ReplaceAll(filename, " ", "-")

        uuid := uuid.New().String()
        fileKey := fmt.Sprintf("receipts/%s-%s", uuid, filename)
        contentType := "application/pdf"
        err := r.storage.UploadFile(c, fileKey, contentType, pdfBuffer, storage.PrivateBucket)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return fileKey, nil</span>

}

func (r *ReceiptService) GetByUserID(userID uuid.UUID, limit, page int) ([]domain.Receipt, int, int, error) <span class="cov0" title="0">{
        user, userErr := r.userRepo.GetUserByID(userID)
        if userErr != nil </span><span class="cov0" title="0">{
                return nil, 0, 0, userErr
        }</span>
        <span class="cov0" title="0">if user == nil || user.Role == "" </span><span class="cov0" title="0">{
                return nil, 0, 0, apperror.BadRequestError(errors.New("invalid user"), "user not found or role is missing")
        }</span>
        <span class="cov0" title="0">if user.Role != domain.LesseeRole </span><span class="cov0" title="0">{
                return nil, 0, 0, apperror.BadRequestError(errors.New("invalid user"), "role mismatch")
        }</span>
        <span class="cov0" title="0">return r.receiptRepo.GetByUserID(userID, limit, page)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package services

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type SupportService struct {
        repo ports.SupportRepository
}

func NewSupportService(repo ports.SupportRepository) ports.SupportService <span class="cov0" title="0">{
        return &amp;SupportService{repo: repo}
}</span>

func (s *SupportService) Create(support *domain.SupportRequest) error <span class="cov0" title="0">{
        return s.repo.Create(support)
}</span>

func (s *SupportService) GetAll(limit int, page int, userID uuid.UUID, isAdmin bool) ([]domain.SupportRequest, int, int, error) <span class="cov0" title="0">{
        return s.repo.GetAll(limit, page, userID, isAdmin)
}</span>

func (s *SupportService) UpdateStatus(id uuid.UUID, status domain.SupportStatus) (*domain.SupportRequest, error) <span class="cov0" title="0">{
        support, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, "Support request not found")
        }</span>

        <span class="cov0" title="0">if status != domain.ProblemOpen &amp;&amp; status != domain.ProblemInProgress &amp;&amp; status != domain.ProblemResolved </span><span class="cov0" title="0">{
                return nil, apperror.UnprocessableEntityError(errors.New("invalid status value"), "Invalid status value")
        }</span>

        <span class="cov0" title="0">support.Status = status

        return support, s.repo.UpdateStatus(id, status)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        stripePkg "github.com/PitiNarak/condormhub-backend/pkg/stripe"
        "github.com/google/uuid"
        "github.com/stripe/stripe-go/v81"
        "github.com/yokeTH/go-pkg/apperror"
)

type TransactionService struct {
        tsxRepo            ports.TransactionRepository
        orderRepo          ports.OrderRepository
        leasingHistoryRepo ports.LeasingHistoryRepository
        stripe             *stripePkg.Stripe
        receiptService     ports.ReceiptService
}

func NewTransactionService(tsxRepo ports.TransactionRepository, orderRepo ports.OrderRepository, stripe *stripePkg.Stripe, leasingHistoryRepo ports.LeasingHistoryRepository, receiptService ports.ReceiptService) ports.TransactionService <span class="cov0" title="0">{
        return &amp;TransactionService{
                tsxRepo:            tsxRepo,
                orderRepo:          orderRepo,
                leasingHistoryRepo: leasingHistoryRepo,
                receiptService:     receiptService,
                stripe:             stripe,
        }
}</span>

func (s *TransactionService) CreateTransaction(orderID uuid.UUID) (*domain.Transaction, *string, error) <span class="cov0" title="0">{
        order, err := s.orderRepo.GetByID(orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if order.PaidTransactionID != "" </span><span class="cov0" title="0">{
                return nil, nil, apperror.BadRequestError(fmt.Errorf("order %s is already paid", orderID), "order is already paid")
        }</span>

        <span class="cov0" title="0">productName := order.LeasingHistory.Dorm.Name
        price := order.Price
        customerEmail := order.LeasingHistory.Lessee.Email

        session, sErr := s.stripe.CreateOneTimePaymentSession(productName, int64(price), customerEmail)
        if sErr != nil </span><span class="cov0" title="0">{
                return nil, nil, apperror.InternalServerError(sErr, "Failed to create payment session")
        }</span>

        <span class="cov0" title="0">tsx := domain.Transaction{
                ID:      session.ID,
                Price:   int64(price),
                OrderID: orderID,
        }
        err = s.tsxRepo.Create(&amp;tsx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return &amp;tsx, &amp;session.URL, nil</span>
}

func (s *TransactionService) UpdateTransactionStatus(c context.Context, event stripe.Event) error <span class="cov0" title="0">{
        var tsx domain.Transaction
        tsx.ID = event.Data.Object["id"].(string)
        switch event.Type </span>{
        case "checkout.session.expired":<span class="cov0" title="0">
                tsx.SessionStatus = domain.StatusExpired</span>
        case "checkout.session.completed":<span class="cov0" title="0">
                tsx.SessionStatus = domain.StatusComplete</span>
        default:<span class="cov0" title="0">
                return apperror.BadRequestError(fmt.Errorf("event type %s is not supported", event.Type), "Failed to update order status")</span>
        }

        <span class="cov0" title="0">if err := s.tsxRepo.Update(&amp;tsx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tsx, err := s.tsxRepo.GetByID(tsx.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := s.orderRepo.Update(&amp;domain.Order{
                ID:                tsx.OrderID,
                PaidTransactionID: tsx.ID,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if tsx.SessionStatus == domain.StatusComplete </span><span class="cov0" title="0">{
                order, err := s.orderRepo.GetByID(tsx.OrderID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">history, err := s.leasingHistoryRepo.GetByID(order.LeasingHistoryID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">ownerID := history.LesseeID
                receiptErr := s.receiptService.Create(c, ownerID, tsx)
                if receiptErr != nil </span><span class="cov0" title="0">{
                        return receiptErr
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package services

import (
        "context"
        "errors"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/PitiNarak/condormhub-backend/pkg/email"
        "github.com/PitiNarak/condormhub-backend/pkg/jwt"
        "github.com/PitiNarak/condormhub-backend/pkg/storage"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
        "golang.org/x/crypto/bcrypt"
)

type UserService struct {
        userRepo     ports.UserRepository
        emailService email.Email
        jwtUtils     *jwt.JWTUtils
        storage      *storage.Storage
}

func NewUserService(UserRepo ports.UserRepository, EmailService email.Email, jwtUtils *jwt.JWTUtils, storage *storage.Storage) ports.UserService <span class="cov0" title="0">{
        return &amp;UserService{userRepo: UserRepo, emailService: EmailService, jwtUtils: jwtUtils, storage: storage}
}</span>

func (s *UserService) ConvertToDTO(user domain.User) dto.UserResponse <span class="cov0" title="0">{
        res := user.ToDTO()
        if user.ProfilePicKey != "" </span><span class="cov0" title="0">{
                res.ProfilePicUrl = s.storage.GetPublicUrl(user.ProfilePicKey)
        }</span>
        <span class="cov0" title="0">return res</span>
}

func (s *UserService) GetStudentEvidenceDTO(c context.Context, studentEvidence string) (*dto.StudentEvidenceUploadResponseBody, error) <span class="cov0" title="0">{
        if studentEvidence == "" </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(errors.New("student evidence for this user does not exist"), "Student evidence for this user does not exist")
        }</span>

        <span class="cov0" title="0">url, err := s.storage.GetSignedUrl(c, studentEvidence, time.Minute*60)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.InternalServerError(err, "error getting signed url")
        }</span>

        <span class="cov0" title="0">res := new(dto.StudentEvidenceUploadResponseBody)
        res.ImageUrl = url
        res.Expired = time.Now().Add(time.Hour)

        return res, nil</span>
}

func (s *UserService) Create(ctx context.Context, user *domain.User) (string, string, error) <span class="cov0" title="0">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)

        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">user.Password = string(hashedPassword)
        create_err := s.userRepo.Create(user)
        if create_err != nil </span><span class="cov0" title="0">{
                return "", "", create_err
        }</span>

        <span class="cov0" title="0">accessToken, refreshToken, err := s.jwtUtils.GenerateKeyPair(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">verifyToken, err := s.jwtUtils.GenerateVerificationToken(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">err = s.emailService.SendVerificationEmail(user.Email, user.Username, verifyToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">return accessToken, refreshToken, nil</span>
}

func (s *UserService) VerifyUser(ctx context.Context, token string) (*domain.User, string, string, error) <span class="cov0" title="0">{
        userID, err := s.jwtUtils.VerifyVerificationToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">if userID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, "", "", apperror.UnauthorizedError(errors.New("token expired"), "token is expired")
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetUserByID(userID)
        if err != nil || user.ID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">user.IsVerified = true

        updateErr := s.userRepo.UpdateUser(user)
        if updateErr != nil </span><span class="cov0" title="0">{
                return nil, "", "", updateErr
        }</span>

        <span class="cov0" title="0">if err := s.jwtUtils.DeleteVerificationToken(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">accessToken, refreshToken, err := s.jwtUtils.GenerateKeyPair(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", apperror.InternalServerError(err, "generate key failed")
        }</span>

        <span class="cov0" title="0">return user, accessToken, refreshToken, nil</span>
}

func (s *UserService) Login(ctx context.Context, email string, password string) (*domain.User, string, string, error) <span class="cov0" title="0">{
        user, getErr := s.userRepo.GetUserByEmail(email)
        if getErr != nil </span><span class="cov0" title="0">{
                return nil, "", "", getErr
        }</span>

        <span class="cov0" title="0">compareErr := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
        if compareErr != nil </span><span class="cov0" title="0">{
                return nil, "", "", apperror.UnauthorizedError(compareErr, "invalid email or password.")
        }</span>
        <span class="cov0" title="0">accessToken, refreshToken, generateErr := s.jwtUtils.GenerateKeyPair(ctx, user.ID)
        if generateErr != nil </span><span class="cov0" title="0">{
                return nil, "", "", generateErr
        }</span>

        <span class="cov0" title="0">return user, accessToken, refreshToken, nil</span>

}

func (s *UserService) RefreshToken(ctx context.Context, refreshToken string) (string, string, error) <span class="cov0" title="0">{
        accessToken, newRefreshToken, err := s.jwtUtils.RefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">return accessToken, newRefreshToken, nil</span>
}

func (s *UserService) UpdateInformation(userID uuid.UUID, data dto.UserInformationRequestBody) (*domain.User, error) <span class="cov0" title="0">{
        if data.Password != "" </span><span class="cov0" title="0">{
                hashedPassword, err := bcrypt.GenerateFromPassword([]byte(data.Password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.InternalServerError(err, "failed to hash password")
                }</span>
                <span class="cov0" title="0">data.Password = string(hashedPassword)</span>
        }
        <span class="cov0" title="0">lifestyles := make([]domain.Lifestyle, len(data.Lifestyles))
        for i, v := range data.Lifestyles </span><span class="cov0" title="0">{
                lifestyles[i] = domain.Lifestyle(v)
        }</span>

        <span class="cov0" title="0">user := domain.User{
                Username:        data.Username,
                Password:        data.Password,
                Firstname:       data.Firstname,
                Lastname:        data.Lastname,
                NationalID:      data.NationalID,
                Gender:          data.Gender,
                StudentEvidence: data.StudentEvidence,
                Lifestyles:      lifestyles,
                BirthDate:       data.BirthDate,
                PhoneNumber:     data.PhoneNumber,
        }

        err := s.userRepo.UpdateInformation(userID, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userInfo, err := s.userRepo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return userInfo, nil</span>
}

func (s *UserService) FirstFillInformation(userID uuid.UUID, data dto.UserFirstFillRequestBody) (*domain.User, error) <span class="cov0" title="0">{

        lifestyles := make([]domain.Lifestyle, len(data.Lifestyles))
        for i, v := range data.Lifestyles </span><span class="cov0" title="0">{
                lifestyles[i] = domain.Lifestyle(v)
        }</span>

        <span class="cov0" title="0">user := domain.User{
                Firstname:          data.Firstname,
                Lastname:           data.Lastname,
                NationalID:         data.NationalID,
                Gender:             data.Gender,
                Lifestyles:         lifestyles,
                BirthDate:          data.BirthDate,
                PhoneNumber:        data.PhoneNumber,
                Role:               domain.Role(data.Role),
                FilledPersonalInfo: true,
        }

        err := s.userRepo.UpdateInformation(userID, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userInfo, err := s.userRepo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return userInfo, nil</span>
}

func (s *UserService) GetUserByEmail(email string) (*domain.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetUserByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (s *UserService) GetUserByID(id uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetUserByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (s *UserService) ResetPasswordCreate(ctx context.Context, email string) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetUserByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">userID, err := uuid.Parse(user.ID.String())
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "cannot sent email")
        }</span>
        <span class="cov0" title="0">token, err := s.jwtUtils.GenerateResetPasswordToken(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = s.emailService.SendResetPasswordEmail(user.Email, user.Username, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *UserService) ResetPassword(ctx context.Context, token string, password string) (*domain.User, string, string, error) <span class="cov0" title="0">{
        userID, err := s.jwtUtils.VerifyResetPasswordToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">if userID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, "", "", apperror.UnauthorizedError(errors.New("token expired"), "token is expired")
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", apperror.BadRequestError(err, "password cannot be hashed")
        }</span>

        <span class="cov0" title="0">user.Password = string(hashedPassword)

        if err = s.userRepo.UpdateUser(user); err != nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">if err := s.jwtUtils.DeleteResetPasswordToken(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">accessToken, refreshToken, err := s.jwtUtils.GenerateKeyPair(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">return user, accessToken, refreshToken, nil</span>
}

func (s *UserService) DeleteAccount(userID uuid.UUID) error <span class="cov0" title="0">{
        err := s.userRepo.DeleteAccount(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *UserService) UploadStudentEvidence(ctx context.Context, filename string, contentType string, fileData io.Reader, userID uuid.UUID) (string, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if user.IsStudentVerified == domain.StatusVerified </span><span class="cov0" title="0">{
                return "", apperror.ForbiddenError(errors.New("you are already verified"), "you are already verified")
        }</span>

        <span class="cov0" title="0">filename = strings.ReplaceAll(filename, " ", "-")
        uuid := uuid.New().String()
        fileKey := fmt.Sprintf("user/%s/student-evidence/%s-%s", userID, uuid, filename)

        if err := s.storage.UploadFile(ctx, fileKey, contentType, fileData, storage.PrivateBucket); err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "error uploading file")
        }</span>
        <span class="cov0" title="0">url, err := s.storage.GetSignedUrl(ctx, fileKey, time.Minute*60)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "error getting signed url")
        }</span>

        <span class="cov0" title="0">if user.StudentEvidence != "" </span><span class="cov0" title="0">{
                if err = s.storage.DeleteFile(ctx, user.StudentEvidence, storage.PrivateBucket); err != nil </span><span class="cov0" title="0">{
                        return "", apperror.InternalServerError(err, "error deleting file")
                }</span>
        }

        <span class="cov0" title="0">user.StudentEvidence = fileKey
        user.IsStudentVerified = domain.StatusPending
        err = s.userRepo.UpdateUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return url, nil</span>
}

func (s *UserService) GetStudentEvidenceByID(ctx context.Context, id uuid.UUID, isSelf bool, isAdmin bool) (*dto.StudentEvidenceUploadResponseBody, error) <span class="cov0" title="0">{
        if !isSelf &amp;&amp; !isAdmin </span><span class="cov0" title="0">{
                return nil, apperror.ForbiddenError(errors.New("unauthorized action"), "You do not have permission to view this evidence")
        }</span>

        <span class="cov0" title="0">user, err := s.GetUserByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GetStudentEvidenceDTO(ctx, user.StudentEvidence)</span>
}

func (s *UserService) ResendVerificationEmailService(ctx context.Context, email string) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetUserByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">verifyToken, err := s.jwtUtils.GenerateVerificationToken(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = s.emailService.SendVerificationEmail(user.Email, user.Username, verifyToken); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *UserService) UploadProfilePicture(ctx context.Context, filename string, contentType string, fileData io.Reader, userID uuid.UUID) (string, error) <span class="cov0" title="0">{
        filename = strings.ReplaceAll(filename, " ", "-")
        uuid := uuid.New().String()
        fileKey := fmt.Sprintf("user/%s/profile-pic/%s-%s", userID, uuid, filename)

        if err := s.storage.UploadFile(ctx, fileKey, contentType, fileData, storage.PublicBucket); err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "error uploading file")
        }</span>
        <span class="cov0" title="0">url := s.storage.GetPublicUrl(fileKey)

        user, err := s.userRepo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if user.ProfilePicKey != "" </span><span class="cov0" title="0">{
                if err = s.storage.DeleteFile(ctx, user.ProfilePicKey, storage.PublicBucket); err != nil </span><span class="cov0" title="0">{
                        return "", apperror.InternalServerError(err, "error deleting file")
                }</span>
        }

        <span class="cov0" title="0">user.ProfilePicKey = fileKey
        err = s.userRepo.UpdateUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return url, nil</span>
}

func (s *UserService) GetLessorIncome(lessorID uuid.UUID, userRole domain.Role) (float64, error) <span class="cov0" title="0">{
        if userRole != domain.LessorRole </span><span class="cov0" title="0">{
                return 0, apperror.ForbiddenError(errors.New("unauthorized action"), "User is not a lessor")
        }</span>
        <span class="cov0" title="0">return s.userRepo.GetLessorIncome(lessorID)</span>
}

func (s *UserService) UpdateUserBanStatus(id uuid.UUID, ban bool) (*domain.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetUserByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if user.Banned == ban </span><span class="cov0" title="0">{
                msg := "user already banned"
                if !user.Banned </span><span class="cov0" title="0">{
                        msg = "user is not banned"
                }</span>
                <span class="cov0" title="0">return nil, apperror.ConflictError(errors.New(msg), msg)</span>
        }
        <span class="cov0" title="0">user.Banned = ban
        return user, s.userRepo.UpdateUser(user)</span>
}

func (s *UserService) GetPending(limit int, page int) ([]domain.User, int, int, error) <span class="cov0" title="0">{
        return s.userRepo.GetPending(limit, page)
}</span>

func (s *UserService) UpdateVerificationStatus(lesseeID uuid.UUID, status domain.VerificationStatus) (*domain.User, error) <span class="cov0" title="0">{
        lessee, err := s.userRepo.GetUserByID(lesseeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if lessee.IsStudentVerified != domain.StatusPending </span><span class="cov0" title="0">{
                return nil, apperror.ConflictError(errors.New("verification not pending"), "verification not pending")
        }</span>

        <span class="cov0" title="0">lessee.IsStudentVerified = status
        return lessee, s.userRepo.UpdateUser(lessee)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package database

import (
        "fmt"
        "log"
        "math"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

type Config struct {
        Host     string `env:"HOST"`
        Port     int    `env:"PORT"`
        User     string `env:"USER"`
        Password string `env:"PASSWORD"`
        DBName   string `env:"NAME"`
        SSLMode  string `env:"SSLMODE"`
}

type Database struct {
        *gorm.DB
}

func New(config Config) (*Database, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s", config.Host, config.Port, config.User, config.Password, config.DBName, config.SSLMode)
        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Info),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to connect database")
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Database{db}, nil</span>
}

func (db *Database) Paginate(value any, tx *gorm.DB, limit int, page int, order string) (int, int, error) <span class="cov0" title="0">{
        var totalRows int64

        offset := (page - 1) * limit
        if err := tx.Model(value).Count(&amp;totalRows).Offset(offset).Limit(limit).Order(order).Find(value).Error; err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov0" title="0">totalPages := int(math.Ceil(float64(totalRows) / float64(limit)))

        return totalPages, int(totalRows), nil</span>

}
</pre>
		
		<pre class="file" id="file24" style="display: none">package dto

type ErrorResponse struct {
        Error string `json:"error"`
}

type SuccessResponse[T any] struct {
        Data T `json:"data"`
}

type PaginationResponse[T any] struct {
        Data       []T        `json:"data"`
        Pagination Pagination `json:"pagination"`
}

type Pagination struct {
        CurrentPage int `json:"current_page"`
        LastPage    int `json:"last_page"`
        Limit       int `json:"limit"`
        Total       int `json:"total"`
}

func Success[T any](data T) SuccessResponse[T] <span class="cov0" title="0">{
        return SuccessResponse[T]{Data: data}
}</span>

func SuccessPagination[T any](data []T, pagination Pagination) PaginationResponse[T] <span class="cov0" title="0">{
        return PaginationResponse[T]{Data: data, Pagination: pagination}
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package handler

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type ContractHandler struct {
        contractService ports.ContractService
}

func NewContractHandler(contractService ports.ContractService) ports.ContractHandler <span class="cov0" title="0">{
        return &amp;ContractHandler{contractService: contractService}
}</span>

// SignContract godoc
// @Summary Sign an existing contract
// @Description Sign a contract by providing contract ID
// @Tags contracts
// @Security Bearer
// @Param contractID path string true "Contract ID"
// @Produce json
// @Success 200 {object} dto.SuccessResponse[dto.ContractResponseBody] "Contract signed successfully"
// @Failure 400 {object} dto.ErrorResponse "Invalid contract ID format"
// @Failure 401 {object} dto.ErrorResponse "Unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Failed to sign contract"
// @Router /contract/{contractID}/sign [patch]
func (ct *ContractHandler) SignContract(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)

        contractID, parseErr := uuid.Parse(c.Params("contractID"))
        if parseErr != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(parseErr, "Invalid contract ID format")
        }</span>

        <span class="cov0" title="0">if err := ct.contractService.UpdateStatus(contractID, domain.Signed, userID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, getErr := ct.contractService.GetContractByContractID(contractID)
        if getErr != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(getErr) </span><span class="cov0" title="0">{
                        return getErr
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(getErr, "get contract error")</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(res.ToDTO()))</span>

}

// CancelContract godoc
// @Summary Cancel an existing contract
// @Description Cancel a contract if it is not signed
// @Tags contracts
// @Security Bearer
// @Param contractID path string true "Contract ID"
// @Produce json
// @Success 200 {object} dto.SuccessResponse[dto.ContractResponseBody] "Contract cancelled successfully"
// @Failure 400 {object} dto.ErrorResponse "Invalid contract ID format or contract cannot be cancelled"
// @Failure 401 {object} dto.ErrorResponse "Unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Failed to cancel contract"
// @Router /contract/{contractID}/cancel [patch]
func (ct *ContractHandler) CancelContract(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)

        contractID, parseErr := uuid.Parse(c.Params("contractID"))
        if parseErr != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(parseErr, "Invalid contract ID format")
        }</span>
        <span class="cov0" title="0">contract, getErr := ct.contractService.GetContractByContractID(contractID)
        if getErr != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(getErr) </span><span class="cov0" title="0">{
                        return getErr
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(getErr, "get contract error")</span>
        }

        <span class="cov0" title="0">if contract.Status == domain.Signed </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("contract is already signed"), "You cannot cancel signed contract")
        }</span>

        <span class="cov0" title="0">if contract.Status == domain.Cancelled </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("contract is already cancelld"), "You cannot cancel cancelled contract")
        }</span>

        <span class="cov0" title="0">if err := ct.contractService.UpdateStatus(contractID, domain.Cancelled, userID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, getErr := ct.contractService.GetContractByContractID(contractID)
        if getErr != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(getErr) </span><span class="cov0" title="0">{
                        return getErr
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(getErr, "get contract error")</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(res.ToDTO()))</span>

}

// DeleteContract godoc
// @Summary Delete a contract
// @Description Permanently delete a contract by ID
// @Tags contracts
// @Security Bearer
// @Param contractID path string true "Contract ID"
// @Success 204 "Contract deleted successfully"
// @Failure 400 {object} dto.ErrorResponse "Invalid contract ID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Failed to delete contract"
// @Router /contract/{contractID} [delete]
func (ct *ContractHandler) Delete(c *fiber.Ctx) error <span class="cov0" title="0">{
        contractID, parseErr := uuid.Parse(c.Params("contractID"))
        if parseErr != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(parseErr, "Invalid contract ID format")
        }</span>

        <span class="cov0" title="0">if err := ct.contractService.DeleteContract(contractID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>

}

// GetContractByContractID godoc
// @Summary Retrieve a contract by contract ID
// @Description Get details of a specific contract
// @Tags contracts
// @Security Bearer
// @Param contractID path string true "Contract ID"
// @Produce json
// @Success 200 {object} dto.SuccessResponse[dto.ContractResponseBody] "Contract retrieved successfully"
// @Failure 400 {object} dto.ErrorResponse "Invalid contract ID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Failed to retrieve contract"
// @Router /contract/{contractID} [get]
func (ct *ContractHandler) GetContractByContractID(c *fiber.Ctx) error <span class="cov0" title="0">{
        contractID, parseErr := uuid.Parse(c.Params("contractID"))
        if parseErr != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(parseErr, "Invalid contract ID format")
        }</span>

        <span class="cov0" title="0">contract, err := ct.contractService.GetContractByContractID(contractID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(dto.Success(contract.ToDTO()))</span>

}

// GetContractByUserID godoc
// @Summary Retrieve contracts by user ID
// @Description Get all contracts associated with a specific user
// @Tags contracts
// @Security Bearer
// @Param limit query int false "Number of contracts to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Produce json
// @Success 200 {object} dto.PaginationResponse[dto.ContractResponseBody] "Contracts retrieved successfully"
// @Failure 400 {object} dto.ErrorResponse "Invalid query parameters"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Failed to retrieve contracts"
// @Router /contract [get]
func (ct *ContractHandler) GetContractByUserID(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)
        limit := min(50, c.QueryInt("limit", 10))
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>
        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">contracts, totalPage, totalRows, err := ct.contractService.GetByUserID(userID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resData := make([]dto.ContractResponseBody, len(*contracts))
        for i, v := range *contracts </span><span class="cov0" title="0">{
                resData[i] = v.ToDTO()
        }</span>

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// GetContractByDormID godoc
// @Summary Retrieve contracts by dorm ID
// @Description Get all contracts associated with a specific dorm
// @Tags contracts
// @Security Bearer
// @Param dormId path string true "Dorm ID"
// @Param limit query int false "Number of contracts to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Produce json
// @Success 200 {object} dto.PaginationResponse[dto.ContractResponseBody] "Contracts retrieved successfully"
// @Failure 400 {object} dto.ErrorResponse "Invalid dorm ID format or query parameters"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Failed to retrieve contracts"
// @Router /contract/{dormID} [get]
func (ct *ContractHandler) GetContractByDormID(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("dormID")
        dormID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "Can not parse UUID")</span>
        }
        <span class="cov0" title="0">limit := min(50, c.QueryInt("limit", 10))
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>
        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">contracts, totalPage, totalRows, err := ct.contractService.GetByDormID(dormID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resData := make([]dto.ContractResponseBody, len(*contracts))
        for i, v := range *contracts </span><span class="cov0" title="0">{
                resData[i] = v.ToDTO()
        }</span>

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package handler

import (
        "errors"
        "net/url"
        "strings"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/go-playground/validator"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type DormHandler struct {
        dormService ports.DormService
}

func NewDormHandler(service ports.DormService) ports.DormHandler <span class="cov0" title="0">{
        return &amp;DormHandler{dormService: service}
}</span>

// Register godoc
// @Summary Create a new dorm
// @Description Add a new room to the database with the given details
// @Tags dorms
// @Security Bearer
// @Accept json
// @Produce json
// @Param dorm body dto.DormCreateRequestBody true "Dorm information"
// @Success 201 {object} dto.SuccessResponse[dto.DormResponseBody] "Dorm successfully created"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 403 {object} dto.ErrorResponse "You do not have permission to create a dorm"
// @Failure 400 {object} dto.ErrorResponse "Your request is invalid"
// @Failure 500 {object} dto.ErrorResponse "Failed to save dorm"
// @Router /dorms [post]
func (d *DormHandler) Create(c *fiber.Ctx) error <span class="cov0" title="0">{
        user := c.Locals("user").(*domain.User)
        userRole := user.Role
        if userRole == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>

        <span class="cov0" title="0">reqBody := new(dto.DormCreateRequestBody)
        if err := c.BodyParser(reqBody); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Your request is invalid")
        }</span>

        <span class="cov0" title="0">userID := c.Locals("userID").(uuid.UUID)

        validate := validator.New()
        if err := validate.Struct(reqBody); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Your request body is invalid")
        }</span>

        <span class="cov0" title="0">dorm := &amp;domain.Dorm{
                Name:      reqBody.Name,
                OwnerID:   userID,
                Size:      reqBody.Size,
                Bedrooms:  reqBody.Bedrooms,
                Bathrooms: reqBody.Bathrooms,
                Address: domain.Address{
                        District:    reqBody.Address.District,
                        Subdistrict: reqBody.Address.Subdistrict,
                        Province:    reqBody.Address.Province,
                        Zipcode:     reqBody.Address.Zipcode,
                },
                Price:       reqBody.Price,
                Description: reqBody.Description,
        }

        if err := d.dormService.Create(userRole, dorm); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "create dorm error")</span>
        }

        <span class="cov0" title="0">data, err := d.dormService.GetByID(dorm.ID)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "get dorm error")</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(dto.Success(data))</span>
}

// Delete godoc
// @Summary Delete a dorm
// @Description Removes a dorm from the database based on the give ID
// @Tags dorms
// @Security Bearer
// @Produce json
// @Param id path string true "DormID"
// @Success 204 "Dorm successfully deleted"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 403 {object} dto.ErrorResponse "You do not have permission to delete this dorm"
// @Failure 404 {object} dto.ErrorResponse "Dorm not found"
// @Failure 500 {object} dto.ErrorResponse "Failed to delete dorm"
// @Router /dorms/{id} [delete]
func (d *DormHandler) Delete(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")
        userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)
        if user.Role == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>

        <span class="cov0" title="0">isAdmin := user.Role == domain.AdminRole

        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">dormID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">if err := d.dormService.Delete(c.Context(), userID, isAdmin, dormID); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "delete dorm error")</span>
        }

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// GetAll godoc
// @Summary Get all dorms by a search string
// @Description Retrieve a list of all dorms filtered by a search query. If no query is provided, all dorms are returned.
// @Tags dorms
// @Param search query string false "Search query"
// @Param minPrice query int false "Filter min price"
// @Param maxPrice query int false "Filter max price"
// @Param district query string false "Filter district price"
// @Param subdistrict query string false "Filter subdistrict price"
// @Param province query string false "Filter province price"
// @Param zipcode query string false "Filter zipcode price"
// @Param limit query int false "Number of dorms to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Produce json
// @Success 200 {object} dto.PaginationResponse[dto.DormResponseBody] "All dorms retrieved successfully"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Failed to retrieve dorms"
// @Router /dorms [get]
func (d *DormHandler) GetAll(c *fiber.Ctx) error <span class="cov0" title="0">{
        limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">search := c.Query("search")
        minPrice := c.QueryInt("minPrice", -1)
        maxPrice := c.QueryInt("maxPrice", -1)

        if minPrice &gt; maxPrice &amp;&amp; minPrice != -1 &amp;&amp; maxPrice != -1 </span><span class="cov0" title="0">{
                err := errors.New("min price cannot more than max price")
                return apperror.BadRequestError(err, err.Error())
        }</span>

        <span class="cov0" title="0">district := c.Query("district")
        subdistrict := c.Query("subdistrict")
        province := c.Query("province")
        zipcode := c.Query("zipcode")

        dorms, totalPages, totalRows, err := d.dormService.GetAll(limit, page, search, minPrice, maxPrice, district, subdistrict, province, zipcode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res := dto.SuccessPagination(dorms, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPages,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// GetByID godoc
// @Summary Get a dorm by ID
// @Description Retrieve a specific dorm based on its ID
// @Tags dorms
// @Produce json
// @Param id path string true "DormID"
// @Success 200 {object} dto.SuccessResponse[dto.DormResponseBody] "Dorm data successfully retrieved"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "Dorm not found"
// @Failure 500 {object} dto.ErrorResponse "Server failed to retrieve dorm"
// @Router /dorms/{id} [get]
func (d *DormHandler) GetByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")

        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">dormID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">dorm, err := d.dormService.GetByID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "get dorm error")</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(dorm))</span>
}

// Update godoc
// @Summary Update an existing dorm
// @Description Modifies an existing room's details based on the given ID
// @Tags dorms
// @Security Bearer
// @Accept json
// @Produce json
// @Param id path string true "DormID"
// @Param dorm body dto.DormUpdateRequestBody true "Updated Room Data"
// @Success 200 {object} dto.SuccessResponse[dto.DormResponseBody] "Dorm data updated successfully"
// @Failure 400 {object} dto.ErrorResponse "Invalid Request"
// @Failure 403 {object} dto.ErrorResponse "unauthorized to update this dorm"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "Dorm not found"
// @Failure 500 {object} dto.ErrorResponse "Server failed to update dorm"
// @Router /dorms/{id} [patch]
func (d *DormHandler) Update(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)

        if user.Role == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>

        <span class="cov0" title="0">isAdmin := user.Role == domain.AdminRole

        id := c.Params("id")
        updateReqBody := new(dto.DormUpdateRequestBody)
        if err := c.BodyParser(updateReqBody); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Your request is invalid")
        }</span>

        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(updateReqBody); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Your request body is invalid")
        }</span>

        <span class="cov0" title="0">if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">dormID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">updatedDorm, err := d.dormService.Update(userID, isAdmin, dormID, updateReqBody)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "update dorm error")</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(updatedDorm))</span>
}

// UploadDormImage godoc
// @Summary Upload multiple images for a dorm
// @Description Upload multiple images for a specific dorm by its ID, by attaching the images as value for the key field name "image", as a multipart form-data
// @Tags dorms
// @Security Bearer
// @Accept multipart/form-data
// @Produce json
// @Param id path string true "DormID"
// @Param image formData file true "DormImage" collectionFormat "multi"
// @Success 200 {object} dto.SuccessResponse[dto.DormImageUploadResponseBody] "Successful image upload"
// @Failure 400 {object} dto.ErrorResponse "Invalid Request"
// @Failure 403 {object} dto.ErrorResponse "unauthorized to upload image to dorm"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "Dorm not found"
// @Failure 500 {object} dto.ErrorResponse "Server failed to upload dorm image"
// @Router /dorms/{id}/images [post]
func (d *DormHandler) UploadDormImage(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">dormID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">form, err := c.MultipartForm()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Invalid multipart form data")
        }</span>

        <span class="cov0" title="0">files := form.File["image"]

        userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)
        if user.Role == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>
        <span class="cov0" title="0">isAdmin := user.Role == domain.AdminRole

        urls := []string{}
        for _, file := range files </span><span class="cov0" title="0">{
                fileData, err := file.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return apperror.InternalServerError(err, "error opening file")
                }</span>
                <span class="cov0" title="0">defer fileData.Close()

                contentType := file.Header.Get("Content-Type")
                if !strings.HasPrefix(contentType, "image/") </span><span class="cov0" title="0">{
                        return apperror.BadRequestError(errors.New("uploaded file is not an image"), "uploaded file is not an image")
                }</span>

                <span class="cov0" title="0">url, err := d.dormService.UploadDormImage(c.Context(), dormID, file.Filename, contentType, fileData, userID, isAdmin)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">urls = append(urls, url)</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(dto.DormImageUploadResponseBody{ImageURL: urls}))</span>
}

// GetByOwnerID godoc
// @Summary Get dorms by owner ID
// @Description Retrieve all dorms of a specific owner ID
// @Tags dorms
// @Param id path string true "OwnerID"
// @Param limit query int false "Number of dorms to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Produce json
// @Success 200 {object} dto.PaginationResponse[dto.DormResponseBody] "All dorms retrieved successfully"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Failed to retrieve dorms"
// @Router /dorms/owner/{id} [get]
func (d *DormHandler) GetByOwnerID(c *fiber.Ctx) error <span class="cov0" title="0">{
        limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">id := c.Params("id")

        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">ownerID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">dorms, totalPages, totalRows, err := d.dormService.GetByOwnerID(ownerID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "get dorms error")</span>
        }

        <span class="cov0" title="0">res := dto.SuccessPagination(dorms, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPages,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// DeleteDormImageByURL godoc
// @Summary Delete a dorm image by its url
// @Description Deletes a dorm image using its percent encoded url from bucket storage. Encode URL using the encodeURIComponent() function.
// @Tags dorms
// @Security Bearer
// @Accept json
// @Produce json
// @Param url path string true "Percent encoded URL"
// @Success 204 "Image deleted successfully"
// @Failure 400 {object} dto.ErrorResponse "Your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 403 {object} dto.ErrorResponse "You do not have permission to delete this dorm image"
// @Failure 404 {object} dto.ErrorResponse "Image not found"
// @Failure 500 {object} dto.ErrorResponse "Failed to delete image"
// @Router /dorms/images/{url} [delete]
func (d *DormHandler) DeleteDormImageByURL(c *fiber.Ctx) error <span class="cov0" title="0">{
        decodedURL, err := url.PathUnescape(c.Params("url"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Invalid URL")
        }</span>

        <span class="cov0" title="0">userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)
        if user.Role == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>

        <span class="cov0" title="0">isAdmin := user.Role == domain.AdminRole

        if err := d.dormService.DeleteImageByURL(c.Context(), decodedURL, userID, isAdmin); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package handler

import (
        "fmt"
        "strings"
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/PitiNarak/condormhub-backend/pkg/storage"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type TestUploadHandler struct {
        storage *storage.Storage
}

func NewTestUploadHandler(storage *storage.Storage) *TestUploadHandler <span class="cov0" title="0">{
        return &amp;TestUploadHandler{
                storage: storage,
        }
}</span>

func (e *TestUploadHandler) UploadToPrivateBucketHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        file, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "file is required")
        }</span>

        <span class="cov0" title="0">fileData, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "error opening file")
        }</span>
        <span class="cov0" title="0">defer fileData.Close()

        filename := strings.ReplaceAll(file.Filename, " ", "-")
        contentType := file.Header.Get("Content-Type")
        uuid := uuid.New().String()
        fileKey := fmt.Sprintf("test/%s-%s", uuid, filename)

        err = e.storage.UploadFile(c.Context(), fileKey, contentType, fileData, storage.PrivateBucket)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "error uploading file")
        }</span>

        <span class="cov0" title="0">url, err := e.storage.GetSignedUrl(c.Context(), fileKey, time.Minute*5)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "error getting signed url")
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(fiber.Map{"url": url, "key": fileKey, "expires": time.Now().Add(time.Minute * 5)}))</span>
}

func (e *TestUploadHandler) UploadToPublicBucketHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        file, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "file is required")
        }</span>

        <span class="cov0" title="0">fileData, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "error opening file")
        }</span>
        <span class="cov0" title="0">defer fileData.Close()

        filename := strings.ReplaceAll(file.Filename, " ", "-")
        contentType := file.Header.Get("Content-Type")
        uuid := uuid.New().String()
        fileKey := fmt.Sprintf("test/%s-%s", uuid, filename)

        err = e.storage.UploadFile(c.Context(), fileKey, contentType, fileData, storage.PublicBucket)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "error uploading file")
        }</span>

        <span class="cov0" title="0">url := e.storage.GetPublicUrl(fileKey)

        return c.Status(fiber.StatusOK).JSON(dto.Success(fiber.Map{"url": url}))</span>
}

func (e *TestUploadHandler) GetSignedUrlHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        fileKey := c.Params("*")
        url, err := e.storage.GetSignedUrl(c.Context(), fileKey, time.Minute*5)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "error getting signed url")
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(fiber.Map{"url": url, "key": fileKey, "expires": time.Now().Add(time.Minute * 5)}))</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package handler

import (
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/gofiber/fiber/v2"
)

type GreetingHandler struct {
}

func NewGreetingHandler() *GreetingHandler <span class="cov0" title="0">{
        return &amp;GreetingHandler{}
}</span>

func (e *GreetingHandler) Greeting(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.Status(fiber.StatusOK).JSON(dto.Success("Hello from CondromHub Api."))
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package handler

import (
        "errors"
        "net/url"
        "strings"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/go-playground/validator"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type LeasingHistoryHandler struct {
        service     ports.LeasingHistoryService
        dormService ports.DormService
}

func NewLeasingHistoryHandler(service ports.LeasingHistoryService, dormService ports.DormService) ports.LeasingHistoryHandler <span class="cov0" title="0">{
        return &amp;LeasingHistoryHandler{service: service, dormService: dormService}
}</span>

// SetEndTimestamp godoc
// @Summary Set end date of a leasing history
// @Description Set end date of a leasing history in the database
// @Tags history
// @Security Bearer
// @Produce json
// @Param id path string true "LeasingHistoryId"
// @Success 204 "Set end timestamp successfully"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or Failed to update leasing history"
// @Router /history/{id} [patch]
func (h *LeasingHistoryHandler) SetEndTimestamp(c *fiber.Ctx) error <span class="cov0" title="0">{
        leasingHistoryID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = h.service.SetEndTimestamp(leasingHistoryID)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// GetByUserID godoc
// @Summary Get all leasing history of current user
// @Description Retrieve a list of all leasing history of current user
// @Tags history
// @Security Bearer
// @Produce json
// @Param limit query int false "Number of leasing histories to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Success 200 {object} dto.PaginationResponse[dto.LeasingHistory] "Retrive history successfully"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format or limit parameter is incorrect or page parameter is incorrect or page exceeded"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Router /history/me [get]
func (h *LeasingHistoryHandler) GetByUserID(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)
        limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">leasingHistory, totalPage, totalRows, err := h.service.GetByUserID(userID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resData := make([]dto.LeasingHistory, len(leasingHistory))
        for i, v := range leasingHistory </span><span class="cov0" title="0">{
                urls := h.service.GetImageUrl(v.Images)
                resData[i] = v.ToDTO(urls)
                resData[i].Images = h.dormService.GetImageUrl(v.Dorm.Images)
        }</span>

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// GetByDormID godoc
// @Summary Get all leasing history by dormid
// @Description Retrieve a list of all leasing history by dormid
// @Tags history
// @Security Bearer
// @Produce json
// @Param id path string true "DormID"
// @Param limit query int false "Number of leasing histories to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Success 200 {object} dto.PaginationResponse[dto.LeasingHistory] "Retrive history successfully"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format or limit parameter is incorrect or page parameter is incorrect or page exceeded"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID"
// @Router /history/bydorm/{id} [get]
func (h *LeasingHistoryHandler) GetByDormID(c *fiber.Ctx) error <span class="cov0" title="0">{
        dormID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">leasingHistory, totalPage, totalRows, err := h.service.GetByDormID(dormID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resData := make([]dto.LeasingHistory, len(leasingHistory))
        for i, v := range leasingHistory </span><span class="cov0" title="0">{
                urls := h.service.GetImageUrl(v.Images)
                resData[i] = v.ToDTO(urls)
        }</span>

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// GetByID godoc
// @Summary Get a leasing history by historyid
// @Description Retrieve a leasing history by historyid
// @Tags history
// @Security Bearer
// @Produce json
// @Param id path string true "HistoryID"
// @Success 200 {object} dto.LeasingHistory "Retrive history successfully"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID"
// @Router /history/{id} [get]
func (h *LeasingHistoryHandler) GetByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        historyID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">leasingHistory, err := h.service.GetByID(historyID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">urls := h.service.GetImageUrl(leasingHistory.Images)
        resData := leasingHistory.ToDTO(urls)
        resData.Images = h.dormService.GetImageUrl(leasingHistory.Dorm.Images)

        return c.Status(fiber.StatusOK).JSON(resData)</span>
}

// Delete godoc
// @Summary Delete a leasing history
// @Description Delete a leasing history in the database
// @Tags history
// @Security Bearer
// @Produce json
// @Param id path string true "LeasingHistoryId"
// @Success 204 "No Content"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or Failed to delete leasing history"
// @Router /history/{id} [delete]
func (h *LeasingHistoryHandler) Delete(c *fiber.Ctx) error <span class="cov0" title="0">{
        leasingHistoryID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = h.service.Delete(leasingHistoryID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// Create godoc
// @Summary Create a new leasing history
// @Description Add a new leasing history to the database
// @Tags history
// @Security Bearer
// @Produce json
// @Param id path string true "DormID"
// @Success 201 {object} dto.SuccessResponse[dto.LeasingHistory] "Dorm successfully created"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "Dorm not found or leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or failed to save leasing history to database"
// @Router /history/{id} [post]
func (h *LeasingHistoryHandler) Create(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)
        dormID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">leasingHistory, err := h.service.Create(userID, dormID)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">urls := h.service.GetImageUrl(leasingHistory.Images)

        res := dto.Success(leasingHistory.ToDTO(urls))

        return c.Status(fiber.StatusCreated).JSON(res)</span>
}

// CreateReview godoc
// @Summary Create a new review
// @Description Add a new review to the database
// @Tags history
// @Security Bearer
// @Produce json
// @Param id path string true "HistoryID"
// @Param user body dto.ReviewCreateRequestBody true "review information"
// @Success 201 {object} dto.SuccessResponse[dto.Review]
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format or your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or failed to save leasing history to database"
// @Router /history/{id}/review [post]
func (h *LeasingHistoryHandler) CreateReview(c *fiber.Ctx) error <span class="cov0" title="0">{
        user := c.Locals("user").(*domain.User)
        body := new(dto.ReviewCreateRequestBody)
        err := c.BodyParser(&amp;body)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>

        <span class="cov0" title="0">validate := validator.New()

        if err := validate.Struct(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>
        <span class="cov0" title="0">historyID, err := parseIdParam(c)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">history, err := h.service.GetByID(historyID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">review, err := h.service.CreateReview(user, historyID, body.Message, int(body.Rate))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">urls := h.service.GetImageUrl(history.Images)
        res := dto.Success(review.ToDTO(urls, history.Lessee.ToDTO()))
        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// GetReviewByDormID godoc
// @Summary Get all reviews by dormid
// @Description Retrieve a list of all reviews by dormid
// @Tags history
// @Produce json
// @Param id path string true "DormID"
// @Param limit query int false "Number of reviews to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Success 200 {object} dto.PaginationResponse[dto.Review] "Retrive reviews successfully"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format or limit parameter is incorrect or page parameter is incorrect or page exceeded"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID"
// @Router /history/bydorm/{id}/review [get]
func (h *LeasingHistoryHandler) GetReviewByDormID(c *fiber.Ctx) error <span class="cov0" title="0">{
        dormID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">reviews, totalPage, totalRows, err := h.service.GetReviewByDormID(dormID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resData := make([]dto.Review, len(reviews))
        for i, v := range reviews </span><span class="cov0" title="0">{
                urls := h.service.GetImageUrl(v.Images)
                if v.Review != nil </span><span class="cov0" title="0">{
                        resData[i] = v.Review.ToDTO(urls, v.Lessee.ToDTO())
                }</span> else<span class="cov0" title="0"> {
                        resData[i] = dto.Review{}
                }</span>
        }

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// UploadReviewImage godoc
// @Summary Upload multiple images for a review
// @Description Upload multiple images for a specific review by its historyID, by attaching the images as value for the key field name "image", as a multipart form-data
// @Tags history
// @Security Bearer
// @Accept multipart/form-data
// @Produce json
// @Param id path string true "historyID"
// @Param image formData file true "ReviewImage" collectionFormat "multi"
// @Success 200 {object} dto.SuccessResponse[dto.ReviewImageUploadResponseBody] "Successful image upload"
// @Failure 400 {object} dto.ErrorResponse "Invalid Request"
// @Failure 403 {object} dto.ErrorResponse "unauthorized to upload image to review"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "History not found"
// @Failure 500 {object} dto.ErrorResponse "Server failed to upload review image"
// @Router /history/{id}/review/images [post]
func (h *LeasingHistoryHandler) UploadReviewImage(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">historyID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">form, err := c.MultipartForm()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Invalid multipart form data")
        }</span>

        <span class="cov0" title="0">files := form.File["image"]

        userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)
        if user.Role == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>
        <span class="cov0" title="0">isAdmin := user.Role == domain.AdminRole

        urls := []string{}
        for _, file := range files </span><span class="cov0" title="0">{
                fileData, err := file.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return apperror.InternalServerError(err, "error opening file")
                }</span>
                <span class="cov0" title="0">defer fileData.Close()

                contentType := file.Header.Get("Content-Type")
                if !strings.HasPrefix(contentType, "image/") </span><span class="cov0" title="0">{
                        return apperror.BadRequestError(errors.New("uploaded file is not an image"), "uploaded file is not an image")
                }</span>

                <span class="cov0" title="0">url, err := h.service.UploadReviewImage(c.Context(), historyID, file.Filename, contentType, fileData, userID, isAdmin)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">urls = append(urls, url)</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(dto.ReviewImageUploadResponseBody{ImageURL: urls}))</span>
}

// DeleteReviewImageByURL godoc
// @Summary Delete a review image by its url
// @Description Deletes a review image using its percent encoded url from bucket storage. Encode URL using encodeURIComponent().
// @Tags history
// @Security Bearer
// @Produce json
// @Param url path string true "Percent encoded URL"
// @Success 204 "Image deleted successfully"
// @Failure 400 {object} dto.ErrorResponse "Your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 403 {object} dto.ErrorResponse "You do not have permission to delete this review image"
// @Failure 404 {object} dto.ErrorResponse "Image not found"
// @Failure 500 {object} dto.ErrorResponse "Failed to delete image"
// @Router /history/review/image/{url} [delete]
func (h *LeasingHistoryHandler) DeleteReviewImageByURL(c *fiber.Ctx) error <span class="cov0" title="0">{
        decodedURL, err := url.PathUnescape(c.Params("url"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Invalid URL")
        }</span>

        <span class="cov0" title="0">userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)
        if user.Role == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>

        <span class="cov0" title="0">isAdmin := user.Role == domain.AdminRole

        if err := h.service.DeleteImageByURL(c.Context(), decodedURL, userID, isAdmin); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// UpdateReview godoc
// @Summary Update a new review
// @Description Update a review in the database
// @Tags history
// @Security Bearer
// @Produce json
// @Param id path string true "HistoryID"
// @Param user body dto.ReviewUpdateRequestBody true "review information"
// @Success 201 {object} dto.SuccessResponse[dto.Review]
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format or your request is invalid or review not exist"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or failed to save leasing history to database"
// @Router /history/{id}/review [patch]
func (h *LeasingHistoryHandler) UpdateReview(c *fiber.Ctx) error <span class="cov0" title="0">{
        user := c.Locals("user").(*domain.User)
        body := new(dto.ReviewUpdateRequestBody)
        err := c.BodyParser(&amp;body)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>

        <span class="cov0" title="0">validate := validator.New()

        if err := validate.Struct(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>

        <span class="cov0" title="0">historyID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">history, err := h.service.GetByID(historyID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">review, err := h.service.UpdateReview(user, historyID, body.Message, int(body.Rate))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">urls := h.service.GetImageUrl(history.Images)
        res := dto.Success(review.ToDTO(urls, history.Lessee.ToDTO()))
        return c.Status(fiber.StatusCreated).JSON(res)</span>
}

// Delete godoc
// @Summary Delete a review
// @Description Delete a review
// @Tags history
// @Security Bearer
// @Produce json
// @Param id path string true "HistoryID"
// @Success 204 "No Content"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "Dorm not found or leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or failed to save leasing history to database"
// @Router /history/{id}/review [delete]
func (h *LeasingHistoryHandler) DeleteReview(c *fiber.Ctx) error <span class="cov0" title="0">{
        user := c.Locals("user").(*domain.User)
        historyID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = h.service.DeleteReview(user, historyID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// GetReportedReview godoc
// @Summary Get all reported reviews
// @Description Endpoint for admins to get a list of all reported reviews
// @Tags admin
// @Security Bearer
// @Produce json
// @Param limit query int false "Number of reviews to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Success 200 {object} dto.PaginationResponse[dto.ReportedReview] "Retrieve reported reviews successfully"
// @Failure 401 {object} dto.ErrorResponse "unauthorized"
// @Failure 403 {object} dto.ErrorResponse "forbidden"
// @Failure 500 {object} dto.ErrorResponse "internal server error"
// @Router /admin/reviews/reported [get]
func (h *LeasingHistoryHandler) GetReportedReviews(c *fiber.Ctx) error <span class="cov0" title="0">{
        limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">leasingHistory, totalPage, totalRows, err := h.service.GetReportedReviews(limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resData := make([]dto.ReportedReview, len(leasingHistory))
        for i, v := range leasingHistory </span><span class="cov0" title="0">{
                urls := h.service.GetImageUrl(v.Images)
                resData[i] = v.Review.ToReportedReviewDTO(urls, v.Lessee.ToDTO(), v.ID)
        }</span>

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// ReportReview godoc
// @Summary Report a review
// @Description Mark a review as reported
// @Tags history
// @Security Bearer
// @Produce json
// @Param id path string true "HistoryID"
// @Success 200 {object} dto.SuccessResponse[dto.Review] "Review reported successfully"
// @Failure 400 {object} dto.ErrorResponse "bad request"
// @Failure 401 {object} dto.ErrorResponse "unauthorized"
// @Failure 403 {object} dto.ErrorResponse "forbidden"
// @Failure 404 {object} dto.ErrorResponse "not found"
// @Failure 409 {object} dto.ErrorResponse "conflict"
// @Failure 500 {object} dto.ErrorResponse "internal server error"
// @Router /history/{id}/review/report [post]
func (h *LeasingHistoryHandler) ReportReview(c *fiber.Ctx) error <span class="cov0" title="0">{
        historyID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">history, err := h.service.ReportReview(historyID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">urls := h.service.GetImageUrl(history.Images)
        data := history.Review.ToDTO(urls, history.Lessee.ToDTO())

        return c.Status(fiber.StatusOK).JSON(dto.Success(data))</span>
}

func parseIdParam(c *fiber.Ctx) (uuid.UUID, error) <span class="cov0" title="0">{
        id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">parsedID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return uuid.Nil, err
                }</span>
                <span class="cov0" title="0">return uuid.Nil, apperror.InternalServerError(err, "Can not parse UUID")</span>
        }
        <span class="cov0" title="0">return parsedID, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package handler

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type LeasingRequestHandler struct {
        service ports.LeasingRequestService
}

func NewLeasingRequestHandler(service ports.LeasingRequestService) ports.LeasingRequestHandler <span class="cov0" title="0">{
        return &amp;LeasingRequestHandler{service: service}
}</span>

// Approve godoc
// @Summary Approve a leasing request
// @Description Approve a leasing request
// @Tags request
// @Security Bearer
// @Produce json
// @Param id path string true "LeasingRequestId"
// @Success 204
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized or lessee cannot approve a request"
// @Failure 404 {object} dto.ErrorResponse "leasing request not found or request is not in the pending status"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or Failed to update leasing request"
// @Router /request/{id}/approve [patch]
func (h *LeasingRequestHandler) Approve(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")
        user := c.Locals("user").(*domain.User)
        if user.Role == domain.LesseeRole </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("user is a lessee"), "lessee cannot approve a request")
        }</span>
        <span class="cov0" title="0">if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.BadRequestError(err, "Incorrect UUID format")</span>
        }

        <span class="cov0" title="0">leasingRequestID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "Can not parse UUID")</span>
        }
        <span class="cov0" title="0">err = h.service.Approve(leasingRequestID, user.ID, user.Role == domain.AdminRole)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// Reject godoc
// @Summary Reject a leasing request
// @Description Reject a leasing request
// @Tags request
// @Security Bearer
// @Produce json
// @Param id path string true "LeasingRequestId"
// @Success 204
// @Failure 400 {object} dto.ErrorResponse "leasing request not found or request is not in the pending status"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized or lessee cannot reject a request"
// @Failure 404 {object} dto.ErrorResponse "leasing request not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or Failed to update leasing request"
// @Router /request/{id}/reject [patch]
func (h *LeasingRequestHandler) Reject(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")
        user := c.Locals("user").(*domain.User)
        if user.Role == domain.LesseeRole </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("user is a lessee"), "lessee cannot reject a request")
        }</span>
        <span class="cov0" title="0">if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.BadRequestError(err, "Incorrect UUID format")</span>
        }

        <span class="cov0" title="0">leasingRequestID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "Can not parse UUID")</span>
        }
        <span class="cov0" title="0">err = h.service.Reject(leasingRequestID, user.ID, user.Role == domain.AdminRole)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// Cancel godoc
// @Summary Cancel a leasing request
// @Description Cancel a leasing request
// @Tags request
// @Security Bearer
// @Produce json
// @Param id path string true "LeasingRequestId"
// @Success 204
// @Failure 400 {object} dto.ErrorResponse "leasing request not found or request is not in the pending status"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized or lessor cannot cancel a request"
// @Failure 404 {object} dto.ErrorResponse "leasing request not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or Failed to update leasing request"
// @Router /request/{id}/cancel [patch]
func (h *LeasingRequestHandler) Cancel(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")
        user := c.Locals("user").(*domain.User)
        if user.Role == domain.LessorRole </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("user is a lessor"), "lessor cannot cancel a request")
        }</span>
        <span class="cov0" title="0">if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.BadRequestError(err, "Incorrect UUID format")</span>
        }

        <span class="cov0" title="0">leasingRequestID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "Can not parse UUID")</span>
        }
        <span class="cov0" title="0">err = h.service.Cancel(leasingRequestID, user.ID, user.Role == domain.AdminRole)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// GetByUserID godoc
// @Summary Get all leasing request by userid
// @Description Retrieve a list of all leasing request by userid
// @Tags request
// @Security Bearer
// @Produce json
// @Param limit query int false "Number of dorms to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Success 200 {object} dto.PaginationResponse[dto.LeasingRequest]
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format or limit parameter is incorrect or page parameter is incorrect"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing request not found"
// @Router /request/me [get]
func (h *LeasingRequestHandler) GetByUserID(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)
        limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">leasingHistory, totalPage, totalRows, err := h.service.GetByUserID(userID, user.Role, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resData := make([]dto.LeasingRequest, len(leasingHistory))
        for i, v := range leasingHistory </span><span class="cov0" title="0">{
                resData[i] = v.ToDTO()
        }</span>

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// Delete godoc
// @Summary Delete a leasing request
// @Description Delete a leasing request in the database
// @Tags request
// @Security Bearer
// @Produce json
// @Param id path string true "LeasingRequestId"
// @Success 204 "No Content"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized or only admin can delete a request"
// @Failure 404 {object} dto.ErrorResponse "leasing request not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or Failed to delete leasing request"
// @Router /request/{id} [delete]
func (h *LeasingRequestHandler) Delete(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")

        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">leasingRequestID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "Can not parse UUID")</span>
        }
        <span class="cov0" title="0">err = h.service.Delete(leasingRequestID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// Create godoc
// @Summary Create a new leasing request
// @Description Add a new leasing request to the database
// @Tags request
// @Security Bearer
// @Produce json
// @Param id path string true "DormID"
// @Param user body dto.LeasingRequestCreateRequestBody true "request information"
// @Success 201 {object} dto.SuccessResponse[dto.LeasingRequest] "Dorm successfully created"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "Dorm not found or leasing request not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID or failed to save leasing request to database"
// @Router /request/{id} [post]
func (h *LeasingRequestHandler) Create(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)
        if user.Role == domain.LessorRole </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("user is a lessor"), "lessor cannot create a request")
        }</span>
        <span class="cov0" title="0">id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">body := new(dto.LeasingRequestCreateRequestBody)
        if err := c.BodyParser(&amp;body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>

        <span class="cov0" title="0">dormID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "Can not parse UUID")</span>
        }
        <span class="cov0" title="0">leasingRequest, err := h.service.Create(userID, dormID, body.Message)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">res := dto.Success(leasingRequest.ToDTO())

        return c.Status(fiber.StatusCreated).JSON(res)</span>
}

// GetByDormID godoc
// @Summary Get all leasing request by dormid
// @Description Retrieve a list of all leasing request by dormid
// @Tags request
// @Security Bearer
// @Produce json
// @Param id path string true "DormID"
// @Param limit query int false "Number of leasing request to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Success 200 {object} dto.PaginationResponse[dto.LeasingRequest] "Retrieve request successfully"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format or limit parameter is incorrect or page parameter is incorrect or page exceeded"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing request not found"
// @Failure 500 {object} dto.ErrorResponse "Can not parse UUID"
// @Router /request/bydorm/{id} [get]
func (h *LeasingRequestHandler) GetByDormID(c *fiber.Ctx) error <span class="cov0" title="0">{
        dormID, err := parseIdParam(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">leasingRequest, totalPage, totalRows, err := h.service.GetByDormID(dormID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resData := make([]dto.LeasingRequest, len(leasingRequest))
        for i, v := range leasingRequest </span><span class="cov0" title="0">{
                resData[i] = v.ToDTO()
        }</span>

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handler

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/go-playground/validator"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type OrderHandler struct {
        OrderService ports.OrderService
}

func NewOrderHandler(service ports.OrderService) ports.OrderHandler <span class="cov0" title="0">{
        return &amp;OrderHandler{OrderService: service}
}</span>

// Create Order godoc
// @Summary Create an order
// @Description Create an order
// @Router /order [post]
// @Tags order
// @Security Bearer
// @Accept json
// @Produce json
// @Param body body dto.OrderRequestBody true "Order request body"
// @Success 200 {object} dto.SuccessResponse[dto.OrderResponseBody] "Order created successfully"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "cannot parse uuid or cannot delete user"
func (o *OrderHandler) CreateOrder(c *fiber.Ctx) error <span class="cov0" title="0">{
        body := new(dto.OrderRequestBody)
        if err := c.BodyParser(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Your request is invalid")
        }</span>

        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Your request body is invalid")
        }</span>

        <span class="cov0" title="0">order, err := o.OrderService.CreateOrder(body.LeasingHistoryID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data := order.ToDTO()
        res := dto.Success(data)

        return c.Status(fiber.StatusCreated).JSON(res)</span>
}

// Get Order by ID godoc
// @Summary Get an order by ID
// @Description Get an order by ID
// @Router /order/{id} [get]
// @Tags order
// @Security Bearer
// @Produce json
// @Param id path string true "Order ID"
// @Success 200 {object} dto.SuccessResponse[dto.OrderResponseBody] "Order retrieved successfully"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "cannot parse uuid or cannot delete user"
func (o *OrderHandler) GetOrderByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        orderID, err := uuid.Parse(c.Params("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Invalid order ID")
        }</span>

        <span class="cov0" title="0">order, serviceErr := o.OrderService.GetOrderByID(orderID)
        if serviceErr != nil </span><span class="cov0" title="0">{
                return serviceErr
        }</span>

        <span class="cov0" title="0">data := order.ToDTO()
        res := dto.Success(data)

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// Get Unpaid Order by ID godoc
// @Summary Get unpaid orders by User ID
// @Description Get unpaid orders by User ID
// @Router /order/unpaid/{userID} [get]
// @Tags order
// @Security Bearer
// @Produce json
// @Param userID path string true "User ID"
// @Param limit query int false "Number of history to be retrieved"
// @Param page query int false "Page to retrieved"
// @Success 200 {object} dto.PaginationResponse[dto.OrderResponseBody] "Order retrieved successfully"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "cannot parse uuid or cannot delete user"
func (o *OrderHandler) GetUnpaidOrderByUserID(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID, err := uuid.Parse(c.Params("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Invalid user ID")
        }</span>

        <span class="cov0" title="0">limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">orders, totalPage, totalRows, errHandler := o.OrderService.GetUnpaidOrderByUserID(userID, limit, page)
        if errHandler != nil </span><span class="cov0" title="0">{
                return errHandler
        }</span>

        <span class="cov0" title="0">responseData := make([]dto.OrderResponseBody, len(orders))
        for i, order := range orders </span><span class="cov0" title="0">{
                responseData[i] = order.ToDTO()
        }</span>

        <span class="cov0" title="0">pagination := dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        }

        res := dto.SuccessPagination(responseData, pagination)

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// Get MT Unpaid Order by ID godoc
// @Summary Get my unpaid orders by ID
// @Description Get my unpaid orders by ID
// @Router /order/unpaid/me [get]
// @Tags order
// @Security Bearer
// @Produce json
// @Param limit query int false "Number of history to be retrieved"
// @Param page query int false "Page to retrieved"
// @Success 200 {object} dto.PaginationResponse[dto.OrderResponseBody] "Unpaid orders retrieved successfully"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "cannot parse uuid or cannot delete user"
func (o *OrderHandler) GetMyUnpaidOrder(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)

        limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">orders, totalPage, totalRows, errHandler := o.OrderService.GetUnpaidOrderByUserID(userID, limit, page)
        if errHandler != nil </span><span class="cov0" title="0">{
                return errHandler
        }</span>

        <span class="cov0" title="0">responseData := make([]dto.OrderResponseBody, len(orders))
        for i, order := range orders </span><span class="cov0" title="0">{
                responseData[i] = order.ToDTO()
        }</span>

        <span class="cov0" title="0">pagination := dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        }

        res := dto.SuccessPagination(responseData, pagination)

        return c.Status(fiber.StatusOK).JSON(res)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handler

import (
        "errors"
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/PitiNarak/condormhub-backend/pkg/storage"

        "github.com/gofiber/fiber/v2"
        "github.com/yokeTH/go-pkg/apperror"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/google/uuid"
)

type OwnershipProofHandler struct {
        storage               *storage.Storage
        ownershipProofService ports.OwnershipProofService
}

func NewOwnershipProofHandler(OwnershipProofService ports.OwnershipProofService, storage *storage.Storage) ports.OwnershipProofHandler <span class="cov0" title="0">{
        return &amp;OwnershipProofHandler{ownershipProofService: OwnershipProofService, storage: storage}
}</span>

// Create godoc
// @Summary Upload new ownership proof
// @Description Upload a new file as ownership proof for a dorm
// @Tags ownership
// @Security Bearer
// @Accept multipart/form-data
// @Produce json
// @Param file formData file true "file"
// @Param id path string true "DormID"
// @Success 200 {object}  dto.SuccessResponse[dto.OwnershipProofResponseBody] "Ownership proof created"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 404 {object} dto.ErrorResponse "Ownershop proof not found"
// @Failure 500 {object} dto.ErrorResponse "Server failed to upload file"
// @Router /ownership/{id}/upload [post]
func (o *OwnershipProofHandler) UploadFile(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">dormID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">file, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "file is required")
        }</span>

        <span class="cov0" title="0">fileData, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "error opening file")
        }</span>
        <span class="cov0" title="0">defer fileData.Close()

        contentType := file.Header.Get("Content-Type")
        url, err := o.ownershipProofService.UploadFile(c.Context(), dormID, file.Filename, contentType, fileData)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">ownershipProof, err := o.ownershipProofService.GetByDormID(dormID)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "error getting ownership proof")</span>
        }
        <span class="cov0" title="0">ownershipProofResponseBody := dto.OwnershipProofResponseBody{
                Url:     url,
                DormID:  dormID,
                AdminID: ownershipProof.AdminID,
                Status:  dto.OwnershipProofStatus(ownershipProof.Status),
        }

        return c.Status(fiber.StatusOK).JSON(dto.Success(ownershipProofResponseBody))</span>
}

// Delete godoc
// @Summary Delete ownership proof
// @Description Delete an ownership proof file
// @Tags ownership
// @Security Bearer
// @Produce json
// @Param id path string true "DormID"
// @Success 204 "Ownership proof successfully deleted"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 404 {object} dto.ErrorResponse "Ownership file not found"
// @Failure 500 {object} dto.ErrorResponse "Failed to delete Ownership file"
// @Router /ownership/{id} [delete]
func (o *OwnershipProofHandler) Delete(c *fiber.Ctx) error <span class="cov0" title="0">{

        id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>
        <span class="cov0" title="0">dormID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">if err = o.ownershipProofService.Delete(c.Context(), dormID); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "error deleting file")</span>
        }
        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>

}

// Approve godoc
// @Summary Approve ownership proof
// @Description Approve a submitted ownership proof for a dorm
// @Tags ownership
// @Security Bearer
// @Produce json
// @Param id path string true "DormID"
// @Success 200 {object} dto.SuccessResponse[dto.OwnershipProofResponseBody] "Ownership proof approved"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 404 {object} dto.ErrorResponse "Ownership file not found"
// @Failure 500 {object} dto.ErrorResponse "Internal server error"
// @Router /ownership/{id}/approve [post]
func (o *OwnershipProofHandler) Approve(c *fiber.Ctx) error <span class="cov0" title="0">{
        adminID, err := c.Locals("userID").(uuid.UUID)
        if !err </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("no user in context"), "your request is unauthorized")
        }</span>

        <span class="cov0" title="0">id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>
        <span class="cov0" title="0">dormID, dormIdRrr := uuid.Parse(id)
        if dormIdRrr != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(dormIdRrr, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">if err := o.ownershipProofService.UpdateStatus(dormID, adminID, domain.OwnershipProofStatus("Approved")); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "error updating file")</span>
        }

        <span class="cov0" title="0">ownershipProof, getErr := o.ownershipProofService.GetByDormID(dormID)
        if getErr != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(getErr) </span><span class="cov0" title="0">{
                        return getErr
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(getErr, "error getting new file")</span>
        }

        <span class="cov0" title="0">url, urlErr := o.ownershipProofService.GetUrl(c.Context(), dormID)

        if urlErr != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(urlErr) </span><span class="cov0" title="0">{
                        return urlErr
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(urlErr, "error getting url")</span>
        }
        <span class="cov0" title="0">ownershipProofResponseBody := dto.OwnershipProofResponseBody{
                Url:     url,
                DormID:  dormID,
                AdminID: ownershipProof.AdminID,
                Status:  dto.OwnershipProofStatus(ownershipProof.Status),
        }

        return c.Status(fiber.StatusOK).JSON(dto.Success(ownershipProofResponseBody))</span>

}

// Reject godoc
// @Summary Reject ownership proof
// @Description Reject a submitted ownership proof for a dorm
// @Tags ownership
// @Security Bearer
// @Produce json
// @Param id path string true "DormID"
// @Success 200 {object}  dto.SuccessResponse[dto.OwnershipProofResponseBody] "Ownership proof rejected"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 404 {object} dto.ErrorResponse "Ownership file not found"
// @Failure 500 {object} dto.ErrorResponse "Internal server error"
// @Router /ownership/{id}/reject [post]
func (o *OwnershipProofHandler) Reject(c *fiber.Ctx) error <span class="cov0" title="0">{
        adminID, err := c.Locals("userID").(uuid.UUID)
        if !err </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("no user in context"), "your request is unauthorized")
        }</span>

        <span class="cov0" title="0">id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>
        <span class="cov0" title="0">dormID, dormIdRrr := uuid.Parse(id)
        if dormIdRrr != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(dormIdRrr, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">if err := o.ownershipProofService.UpdateStatus(dormID, adminID, domain.OwnershipProofStatus("Rejected")); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "error updating file")</span>
        }

        <span class="cov0" title="0">ownershipProof, getErr := o.ownershipProofService.GetByDormID(dormID)
        if getErr != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(getErr) </span><span class="cov0" title="0">{
                        return getErr
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(getErr, "error getting new file")</span>
        }
        <span class="cov0" title="0">url, urlErr := o.ownershipProofService.GetUrl(c.Context(), dormID)
        if urlErr != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(urlErr) </span><span class="cov0" title="0">{
                        return urlErr
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(urlErr, "error getting url")</span>
        }
        <span class="cov0" title="0">ownershipProofResponseBody := dto.OwnershipProofResponseBody{
                Url:     url,
                DormID:  dormID,
                AdminID: ownershipProof.AdminID,
                Status:  dto.OwnershipProofStatus(ownershipProof.Status),
        }

        return c.Status(fiber.StatusOK).JSON(dto.Success(ownershipProofResponseBody))</span>
}

// GetByDormID godoc
// @Summary Get ownership proof by Dorm ID
// @Description Retrieve ownership proof for a specific dorm
// @Tags ownership
// @Security Bearer
// @Produce json
// @Param id path string true "DormID"
// @Success 200 {object}  dto.SuccessResponse[dto.OwnershipProofResponseBody] "Ownership proof retrieved successfully"
// @Failure 400 {object} dto.ErrorResponse "Incorrect UUID format"
// @Failure 404 {object} dto.ErrorResponse "Ownership file not found"
// @Failure 500 {object} dto.ErrorResponse "Internal server error"
// @Router /ownership/{id} [get]
func (o *OwnershipProofHandler) GetByDormID(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>
        <span class="cov0" title="0">dormID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">ownershipProof, getErr := o.ownershipProofService.GetByDormID(dormID)
        if getErr != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(getErr) </span><span class="cov0" title="0">{
                        return getErr
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(getErr, "error getting ownership proof")</span>
        }

        <span class="cov0" title="0">fileKey := ownershipProof.FileKey
        //get key file
        url, urlErr := o.storage.GetSignedUrl(c.Context(), fileKey, time.Minute*60)
        if urlErr != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(urlErr, "error getting url")
        }</span>

        <span class="cov0" title="0">ownershipProofResponseBody := dto.OwnershipProofResponseBody{
                Url:     url,
                DormID:  dormID,
                AdminID: ownershipProof.AdminID,
                Status:  dto.OwnershipProofStatus(ownershipProof.Status),
        }

        return c.Status(fiber.StatusOK).JSON(dto.Success(ownershipProofResponseBody))</span>

}
</pre>
		
		<pre class="file" id="file33" style="display: none">package handler

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
)

type ReceiptHandler struct {
        receiptService ports.ReceiptService
}

func NewReceiptHandler(service ports.ReceiptService) ports.ReceiptHandler <span class="cov0" title="0">{
        return &amp;ReceiptHandler{receiptService: service}
}</span>

// GetByUserID godoc
// @Summary Retrieve receipts by user ID
// @Description Get all receipts associated with a specific user
// @Tags receipt
// @Param limit query int false "Number of receipts to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Produce json
// @Success 200 {object} dto.PaginationResponse[dto.ReceiptResponseBody] "Receipts retrieved successfully"
// @Failure 400 {object} dto.ErrorResponse "Invalid query parameters"
// @Failure 500 {object} dto.ErrorResponse "Failed to retrieve receipts"
// @Router /receipt [get]
func (r *ReceiptHandler) GetByUserID(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)
        limit := min(50, c.QueryInt("limit", 10))
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>
        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">receipts, totalPage, totalRows, err := r.receiptService.GetByUserID(userID, limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resData := make([]dto.ReceiptResponseBody, len(receipts))
        for i, v := range receipts </span><span class="cov0" title="0">{
                url, err := r.receiptService.GetUrl(c.Context(), v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">resData[i] = v.ToDTO(url)</span>
        }

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPage,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package handler

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/go-playground/validator"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type SupportHandler struct {
        service ports.SupportService
}

func NewSupportHandler(service ports.SupportService) ports.SupportHandler <span class="cov0" title="0">{
        return &amp;SupportHandler{service: service}
}</span>

// Create godoc
// @Summary Submit a support request
// @Description Let a user send a message to the admin
// @Tags support
// @Security Bearer
// @Accept json
// @Produce json
// @Param request body dto.SupportRequestBody true "Support Request"
// @Success 201 {object} dto.SuccessResponse[dto.SupportResponseBody] "Support request submitted successfully"
// @Failure 400 {object} dto.ErrorResponse "Your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Could not submit support request"
// @Router /support [post]
func (h *SupportHandler) Create(c *fiber.Ctx) error <span class="cov0" title="0">{
        reqBody := new(dto.SupportRequestBody)
        if err := c.BodyParser(reqBody); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Your request is invalid")
        }</span>
        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(reqBody); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Your request body is invalid")
        }</span>

        <span class="cov0" title="0">userID := c.Locals("userID").(uuid.UUID)
        support := &amp;domain.SupportRequest{
                UserID:  userID,
                Message: reqBody.Message,
        }
        if err := h.service.Create(support); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(dto.Success(support.ToDTO()))</span>
}

// GetAll godoc
// @Summary Get all support requests
// @Description Retrieve a list of all support requests.
// @Tags support
// @Security Bearer
// @Param limit query int false "Number of support requests to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Produce json
// @Success 200 {object} dto.PaginationResponse[dto.SupportResponseBody] "All support requests retrieved successfully"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "Could not fetch support requests"
// @Router /support [get]
func (h *SupportHandler) GetAll(c *fiber.Ctx) error <span class="cov0" title="0">{
        limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)
        if user.Role == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>
        <span class="cov0" title="0">isAdmin := user.Role == domain.AdminRole

        supports, totalPages, totalRows, err := h.service.GetAll(limit, page, userID, isAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resData := make([]dto.SupportResponseBody, len(supports))
        for i, support := range supports </span><span class="cov0" title="0">{
                resData[i] = support.ToDTO()
        }</span>

        <span class="cov0" title="0">res := dto.SuccessPagination(resData, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPages,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// UpdateStatus godoc
// @Summary Update a support request's status
// @Description Modifies an existing support request's status based on the given ID. The possible status are OPEN, IN-PROGRESS, and RESOLVED.
// @Tags support
// @Security Bearer
// @Accept json
// @Produce json
// @Param id path string true "SupportRequestID"
// @Param dorm body dto.UpdateStatusRequestBody true "Status update"
// @Success 200 {object} dto.SuccessResponse[dto.SupportResponseBody] "Status updated"
// @Failure 400 {object} dto.ErrorResponse "Invalid Request"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 403 {object} dto.ErrorResponse "You do not have permission to update support request status"
// @Failure 404 {object} dto.ErrorResponse "Support request not found"
// @Failure 422 {object} dto.ErrorResponse "Invalid status value"
// @Failure 500 {object} dto.ErrorResponse "Server failed to update support request status"
// @Router /support/{id} [patch]
func (h *SupportHandler) UpdateStatus(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")
        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>
        <span class="cov0" title="0">supportID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">req := new(dto.UpdateStatusRequestBody)
        if err = c.BodyParser(req); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Your request is invalid")
        }</span>

        <span class="cov0" title="0">validate := validator.New()
        if err = validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Validation failed")
        }</span>

        <span class="cov0" title="0">status := domain.SupportStatus(req.Status)
        updatedSupport, err := h.service.UpdateStatus(supportID, status)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(updatedSupport.ToDTO()))</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package handler

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/PitiNarak/condormhub-backend/pkg/stripe"
        "github.com/gofiber/fiber/v2"
        "github.com/stripe/stripe-go/v81/webhook"
        "github.com/yokeTH/go-pkg/apperror"
)

type TransactionHandler struct {
        tsxService   ports.TransactionService
        stripeConfig *stripe.Config
}

func NewTransactionHandler(orderService ports.TransactionService, stripeConfig *stripe.Config) ports.TransactionHandler <span class="cov0" title="0">{
        return &amp;TransactionHandler{tsxService: orderService, stripeConfig: stripeConfig}
}</span>

// Create Transaction godoc
// @Summary Create a transaction
// @Description Create a transaction
// @Router /transaction [post]
// @Tags transaction
// @Security Bearer
// @Accept json
// @Produce json
// @Param body body dto.TransactionRequestBody true "Transaction request body"
// @Success 200 {object} dto.SuccessResponse[dto.CreateTransactionResponseBody] "Transaction created successfully"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "leasing history not found"
// @Failure 500 {object} dto.ErrorResponse "cannot parse uuid or cannot delete user"
func (h *TransactionHandler) CreateTransaction(c *fiber.Ctx) error <span class="cov0" title="0">{
        var reqBody *dto.TransactionRequestBody
        if err := c.BodyParser(&amp;reqBody); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Failed to parse request body")
        }</span>

        <span class="cov0" title="0">_, url, err := h.tsxService.CreateTransaction(reqBody.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res := dto.Success(dto.CreateTransactionResponseBody{
                CheckoutUrl: *url,
        })

        return c.Status(fiber.StatusCreated).JSON(res)</span>
}

func (h *TransactionHandler) Webhook(c *fiber.Ctx) error <span class="cov0" title="0">{
        payload := c.Body()

        event, err := webhook.ConstructEventWithOptions(payload, c.Get("Stripe-Signature"), h.stripeConfig.StripeSignatureKey, webhook.ConstructEventOptions{
                IgnoreAPIVersionMismatch: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Failed to construct event")
        }</span>

        <span class="cov0" title="0">updateErr := h.tsxService.UpdateTransactionStatus(c.Context(), event)
        if updateErr != nil </span><span class="cov0" title="0">{
                return updateErr
        }</span>

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package handler

import (
        "errors"
        "strings"
        "time"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/PitiNarak/condormhub-backend/pkg/utils"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type UserHandler struct {
        userService ports.UserService
}

func NewUserHandler(UserService ports.UserService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{userService: UserService}
}</span>

// VerifyEmail godoc
// @Summary Verify email
// @Description Verify email
// @Tags user
// @Accept json
// @Produce json
// @Param user body dto.VerifyRequestBody true "token"
// @Success 200 {object} dto.SuccessResponse[dto.TokenWithUserInformationResponseBody] "email is verified successfully"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "system cannot verify your email"
// @Router /user/verify [post]
func (h *UserHandler) VerifyEmail(c *fiber.Ctx) error <span class="cov0" title="0">{
        body := new(dto.VerifyRequestBody)

        if err := c.BodyParser(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>
        <span class="cov0" title="0">validate := validator.New()

        if err := validate.Struct(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>
        <span class="cov0" title="0">user, accessToken, refreshToken, err := h.userService.VerifyUser(c.Context(), body.Token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data := dto.TokenWithUserInformationResponseBody{
                AccessToken:     accessToken,
                RefreshToken:    refreshToken,
                UserInformation: h.userService.ConvertToDTO(*user),
        }

        res := dto.Success(data)

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// FirstFillInformation godoc
// @Summary Fill user information first time
// @Description Fill user information first time
// @Tags user
// @Security Bearer
// @Accept json
// @Produce json
// @Param user body dto.UserFirstFillRequestBody true "user information"
// @Success 200 {object} dto.SuccessResponse[dto.UserResponse] "user successfully updated account information"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "system cannot update your account information"
// @Router /user/firstfill [patch]
func (h *UserHandler) FirstFillInformation(c *fiber.Ctx) error <span class="cov0" title="0">{
        var requestBody *dto.UserFirstFillRequestBody

        user := c.Locals("user").(*domain.User)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("no user in context"), "your request is unauthorized")
        }</span>

        <span class="cov0" title="0">err := c.BodyParser(&amp;requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>

        <span class="cov0" title="0">validate := validator.New()
        lifeStyleErr := validate.RegisterValidation("lifestyle", utils.ValidateLifestyles)
        if lifeStyleErr != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(lifeStyleErr, "your lifestyle-tag is incorrect format")
        }</span>

        <span class="cov0" title="0">phoneNumberErr := validate.RegisterValidation("phoneNumber", utils.ValidatePhone)
        if phoneNumberErr != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(phoneNumberErr, "your phone number is incorrect format")
        }</span>

        <span class="cov0" title="0">roleErr := validate.RegisterValidation("role", utils.ValidateRole)

        if roleErr != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(roleErr, "your role is incorrect format")
        }</span>

        <span class="cov0" title="0">if err := validate.Struct(requestBody); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>

        <span class="cov0" title="0">userInfo, err := h.userService.FirstFillInformation(user.ID, *requestBody)

        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "system cannot update your account information")
        }</span>

        <span class="cov0" title="0">res := dto.Success(h.userService.ConvertToDTO(*userInfo))

        return c.Status(fiber.StatusOK).JSON(res)</span>

}

// UpdateUserInformation godoc
// @Summary Update user information
// @Description Update user information
// @Tags user
// @Security Bearer
// @Accept json
// @Produce json
// @Param user body dto.UserInformationRequestBody true "user information"
// @Success 200 {object} dto.SuccessResponse[dto.UserResponse] "user successfully updated account information"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "system cannot update your account information"
// @Router /user [patch]
func (h *UserHandler) UpdateUserInformation(c *fiber.Ctx) error <span class="cov0" title="0">{
        var requestBody *dto.UserInformationRequestBody

        user := c.Locals("user").(*domain.User)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("no user in context"), "your request is unauthorized")
        }</span>

        <span class="cov0" title="0">err := c.BodyParser(&amp;requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>

        <span class="cov0" title="0">validate := validator.New()
        lifeStyleErr := validate.RegisterValidation("lifestyle", utils.ValidateLifestyles)
        if lifeStyleErr != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(lifeStyleErr, "your lifestyle-tag is incorrect format")
        }</span>

        <span class="cov0" title="0">phoneNumberErr := validate.RegisterValidation("phoneNumber", utils.ValidatePhone)
        if phoneNumberErr != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(phoneNumberErr, "your phone number is incorrect format")
        }</span>

        <span class="cov0" title="0">if err := validate.Struct(requestBody); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>

        <span class="cov0" title="0">userInfo, err := h.userService.UpdateInformation(user.ID, *requestBody)

        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "system cannot update your account information")
        }</span>

        <span class="cov0" title="0">res := dto.Success(h.userService.ConvertToDTO(*userInfo))

        return c.Status(fiber.StatusOK).JSON(res)</span>

}

// ResetPassword godoc
// @Summary Reset password
// @Description Reset password
// @Tags user
// @Accept json
// @Produce json
// @Param user body dto.ResetPasswordRequestBody true "token"
// @Success 200 {object} dto.SuccessResponse[dto.TokenWithUserInformationResponseBody] "password reset successfully"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid
// @Failure 500 {object} dto.ErrorResponse "system cannot reset password"
// @Router /user/newpassword [post]
func (h *UserHandler) ResetPassword(c *fiber.Ctx) error <span class="cov0" title="0">{
        body := new(dto.ResetPasswordRequestBody)

        if err := c.BodyParser(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>

        <span class="cov0" title="0">validate := validator.New()

        if err := validate.Struct(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>
        <span class="cov0" title="0">tokenString := body.Token
        if tokenString == "" </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("no token in header"), "your request header is incorrect")
        }</span>

        <span class="cov0" title="0">user, accessToken, refreshToken, err := h.userService.ResetPassword(c.Context(), tokenString, body.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data := dto.TokenWithUserInformationResponseBody{
                AccessToken:     accessToken,
                RefreshToken:    refreshToken,
                UserInformation: user.ToDTO(),
        }

        res := dto.Success(data)

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// ResendVerificationEmail godoc
// @Summary Resend verification email
// @Description Resend verification email
// @Tags user
// @Accept json
// @Produce json
// @Param user body dto.ResetPasswordCreateRequestBody true "token"
// @Success 204 "email is sent to user successfully"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid
// @Failure 500 {object} dto.ErrorResponse "system cannot resend verification email"
// @Router /user/resetpassword [post]
func (h *UserHandler) ResetPasswordCreate(c *fiber.Ctx) error <span class="cov0" title="0">{
        body := new(dto.ResetPasswordCreateRequestBody)

        if err := c.BodyParser(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>
        <span class="cov0" title="0">validate := validator.New()

        if err := validate.Struct(body); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>

        <span class="cov0" title="0">err := h.userService.ResetPasswordCreate(c.Context(), body.Email)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// Register godoc
// @Summary Register new user
// @Description Register new user
// @Tags auth
// @Accept json
// @Produce json
// @Param user body dto.RegisterRequestBody true "user information"
// @Success 201 {object} dto.SuccessResponse[dto.TokenWithUserInformationResponseBody] "user successfully registered"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid"
// @Failure 500 {object} dto.ErrorResponse "system cannot register user"
// @Router /auth/register [post]
func (h *UserHandler) Register(c *fiber.Ctx) error <span class="cov0" title="0">{
        user := new(dto.RegisterRequestBody)
        err := c.BodyParser(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>

        <span class="cov0" title="0">validate := validator.New()

        if err := validate.Struct(user); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>
        <span class="cov0" title="0">gormUser := &amp;domain.User{
                Email:    user.Email,
                Username: user.UserName,
                Password: user.Password,
        }

        accessToken, refreshToken, err := h.userService.Create(c.Context(), gormUser)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data := dto.TokenWithUserInformationResponseBody{
                AccessToken:     accessToken,
                RefreshToken:    refreshToken,
                UserInformation: h.userService.ConvertToDTO(*gormUser),
        }

        res := dto.Success(data)

        return c.Status(fiber.StatusCreated).JSON(res)</span>

}

// Login godoc
// @Summary Refresh user
// @Description Refresh user
// @Tags auth
// @Accept json
// @Produce json
// @Param user body dto.RefreshTokenRequestBody true "user information"
// @Success 200 {object} dto.SuccessResponse[dto.TokenResponseBody] "user successfully Refresh in"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "user not found"
// @Failure 500 {object} dto.ErrorResponse "system cannot refresh user"
// @Router /auth/refresh [post]
func (h *UserHandler) RefreshToken(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req dto.RefreshTokenRequestBody
        err := c.BodyParser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>
        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>

        <span class="cov0" title="0">accessToken, refreshToken, loginErr := h.userService.RefreshToken(c.Context(), req.RefreshToken)
        if loginErr != nil </span><span class="cov0" title="0">{
                return loginErr
        }</span>

        <span class="cov0" title="0">data := dto.TokenResponseBody{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
        }

        res := dto.Success(data)

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// Login godoc
// @Summary Login user
// @Description Login user
// @Tags auth
// @Accept json
// @Produce json
// @Param user body dto.LoginRequestBody true "user information"
// @Success 200 {object} dto.SuccessResponse[dto.TokenWithUserInformationResponseBody] "user successfully logged in"
// @Failure 400 {object} dto.ErrorResponse "your request is invalid"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "user not found"
// @Failure 500 {object} dto.ErrorResponse "system cannot login user"
// @Router /auth/login [post]
func (h *UserHandler) Login(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req dto.LoginRequestBody
        err := c.BodyParser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request is invalid")
        }</span>
        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "your request body is incorrect")
        }</span>

        <span class="cov0" title="0">user, accessToken, refreshToken, loginErr := h.userService.Login(c.Context(), req.Email, req.Password)
        if loginErr != nil </span><span class="cov0" title="0">{
                return loginErr
        }</span>

        <span class="cov0" title="0">data := dto.TokenWithUserInformationResponseBody{
                AccessToken:     accessToken,
                RefreshToken:    refreshToken,
                UserInformation: h.userService.ConvertToDTO(*user),
        }

        res := dto.Success(data)

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

// GetUserInfo godoc
// @Summary Get user information
// @Description Get user information
// @Tags user
// @Security Bearer
// @Produce json
// @Success 200 {object} dto.SuccessResponse[dto.UserResponse] "get user information successfully"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "system cannot get user information"
// @Router /user/me [get]
func (h *UserHandler) GetUserInfo(c *fiber.Ctx) error <span class="cov0" title="0">{
        user := c.Locals("user").(*domain.User)
        res := dto.Success(h.userService.ConvertToDTO(*user))
        return c.Status(fiber.StatusOK).JSON(res)
}</span>

// DeleteAccount godoc
// @Summary Delete a user account
// @Description Delete a user account
// @Tags user
// @Security Bearer
// @Accept json
// @Produce json
// @Success 204 "account successfully deleted"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "cannot parse uuid or cannot delete user"
// @Router /user/ [delete]
func (h *UserHandler) DeleteAccount(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)
        err := h.userService.DeleteAccount(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// GetUserByID godoc
// @Summary GetUserByID
// @Description Get User By ID
// @Tags user
// @Security Bearer
// @Produce json
// @Param id path string true "user id"
// @Success 200 {object} dto.SuccessResponse[dto.UserResponse] "get user information successfully"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 500 {object} dto.ErrorResponse "system cannot get user information"
// @Router /user/{id} [get]
func (h *UserHandler) GetUserByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID, err := uuid.Parse(c.Params("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "invalid user id")
        }</span>
        <span class="cov0" title="0">user, err := h.userService.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "get user by id failed")</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(h.userService.ConvertToDTO(*user)))</span>
}

// UploadStudentEvidence godoc
// @Summary Upload an evidence for student verification
// @Description Upload an image of a student ID card, by attaching the image as a value for the key field name "image", as a multipart form-data
// @Tags user
// @Security Bearer
// @Accept multipart/form-data
// @Produce json
// @Param image formData file true "Student ID image"
// @Success 200 {object} dto.SuccessResponse[dto.StudentEvidenceUploadResponseBody] "Evidence uploaded successfully"
// @Failure 400 {object} dto.ErrorResponse "File is required"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 403 {object} dto.ErrorResponse "forbidden"
// @Failure 404 {object} dto.ErrorResponse "User not found"
// @Failure 500 {object} dto.ErrorResponse "Server failed to upload file"
// @Router /user/studentEvidence [post]
func (h *UserHandler) UploadStudentEvidence(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)

        file, err := c.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "file is required")
        }</span>

        <span class="cov0" title="0">fileData, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "error opening file")
        }</span>
        <span class="cov0" title="0">defer fileData.Close()

        contentType := file.Header.Get("Content-Type")
        if !strings.HasPrefix(contentType, "image/") </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("uploaded file is not an image"), "uploaded file is not an image")
        }</span>

        <span class="cov0" title="0">url, err := h.userService.UploadStudentEvidence(c.Context(), file.Filename, contentType, fileData, userID)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(dto.StudentEvidenceUploadResponseBody{ImageUrl: url, Expired: time.Now().Add(time.Hour)}))</span>
}

// GetStudentEvidenceByID godoc
// @Summary Get student evidence by user id
// @Description Get student evidence by user id
// @Tags user
// @Security Bearer
// @Produce json
// @Param id path string true "userID"
// @Success 200 {object} dto.SuccessResponse[dto.StudentEvidenceUploadResponseBody] "Get student evidence successfully"
// @Failure 400 {object} dto.ErrorResponse "invalid user id"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 403 {object} dto.ErrorResponse "unauthorized to view this evidence"
// @Failure 404 {object} dto.ErrorResponse "User or evidence not found"
// @Failure 500 {object} dto.ErrorResponse "system cannot get user's student evidence"
// @Router /user/{id}/studentEvidence [get]
func (h *UserHandler) GetStudentEvidenceByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID, err := uuid.Parse(c.Params("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "invalid user id")
        }</span>

        <span class="cov0" title="0">localUser := c.Locals("user").(*domain.User)
        if localUser.Role == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>
        <span class="cov0" title="0">isSelf := localUser.ID == userID
        isAdmin := localUser.Role == domain.AdminRole

        evidence, err := h.userService.GetStudentEvidenceByID(c.Context(), userID, isSelf, isAdmin)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "get student evidence by id failed")</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(evidence))</span>
}

// SendConfirmationEmailAgain godoc
// @Summary SendConfirmationEmailAgain
// @Description Re send the confirmation email
// @Tags user
// @Security Bearer
// @Produce json
// @Success 204 "resend verification email successfully"
// @Failure 500 {object} dto.ErrorResponse "system cannot verification email"
// @Router /user/resend [post]
func (h *UserHandler) ResendVerificationEmailHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        user, ok := c.Locals("user").(*domain.User)
        if !ok </span><span class="cov0" title="0">{
                return apperror.InternalServerError(errors.New("can't get user form context"), "get user information error")
        }</span>
        <span class="cov0" title="0">if err := h.userService.ResendVerificationEmailService(c.Context(), user.Email); err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(errors.New("can't send confirmation email"), "resend email error")</span>
        }
        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// UploadProfilePicture godoc
// @Summary Upload user profile picture
// @Description Upload an profile picture for the current user, by attaching the image as a value for the key field name "image", as a multipart form-data
// @Tags user
// @Security Bearer
// @Accept multipart/form-data
// @Produce json
// @Param image formData file true "Profile picture image"
// @Success 200 {object} dto.SuccessResponse[dto.ProfilePictureUploadResponseBody] "Profile picture updated"
// @Failure 400 {object} dto.ErrorResponse "File is required"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 404 {object} dto.ErrorResponse "User not found"
// @Failure 500 {object} dto.ErrorResponse "Server failed to upload file"
// @Router /user/profilePic [post]
func (h *UserHandler) UploadProfilePicture(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)

        file, err := c.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "file is required")
        }</span>

        <span class="cov0" title="0">fileData, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "error opening file")
        }</span>
        <span class="cov0" title="0">defer fileData.Close()

        contentType := file.Header.Get("Content-Type")
        if !strings.HasPrefix(contentType, "image/") </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("uploaded file is not an image"), "uploaded file is not an image")
        }</span>

        <span class="cov0" title="0">url, err := h.userService.UploadProfilePicture(c.Context(), file.Filename, contentType, fileData, userID)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(dto.ProfilePictureUploadResponseBody{ImageURL: url}))</span>
}

// GetLessorIncomes godoc
// @Summary Get monthly income for a lessor
// @Description Retrieve the monthly leasing income of a lessor based on leasing history
// @Tags user
// @Security Bearer
// @Produce json
// @Success 200 {object} dto.SuccessResponse[dto.LessorIncomeResponseBody] "Successfully retrieve income"
// @Failure 401 {object} dto.ErrorResponse "your request is unauthorized"
// @Failure 403 {object} dto.ErrorResponse "User is not a lessor"
// @Failure 500 {object} dto.ErrorResponse "system cannot get lessor income"
// @Router /user/income [get]
func (h *UserHandler) GetLessorIncome(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uuid.UUID)
        user := c.Locals("user").(*domain.User)
        userRole := user.Role
        if userRole == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("unauthorized"), "user role is missing")
        }</span>

        <span class="cov0" title="0">income, err := h.userService.GetLessorIncome(userID, userRole)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(dto.LessorIncomeResponseBody{Income: income}))</span>
}

// BanUser godoc
// @Summary Ban a user
// @Description Ban a user by their ID. Only admins are allowed to use this endpoint
// @Tags admin
// @Security Bearer
// @Produce json
// @Param id path string true "userID"
// @Success 200 {object} dto.SuccessResponse[dto.UserResponse] "User banned"
// @Failure 400 {object} dto.ErrorResponse "bad request"
// @Failure 401 {object} dto.ErrorResponse "unauthorized"
// @Failure 403 {object} dto.ErrorResponse "forbidden"
// @Failure 404 {object} dto.ErrorResponse "not found"
// @Failure 409 {object} dto.ErrorResponse "confilct"
// @Failure 500 {object} dto.ErrorResponse "internal server error"
// @Router /admin/user/{id}/ban [patch]
func (h *UserHandler) BanUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")

        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">updatedUser, err := h.userService.UpdateUserBanStatus(userID, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(updatedUser.ToDTO()))</span>
}

// UnbanUser godoc
// @Summary Unban a user
// @Description Unban a user by their ID. Only admins are allowed to use this endpoint
// @Tags admin
// @Security Bearer
// @Produce json
// @Param id path string true "userID"
// @Success 200 {object} dto.SuccessResponse[dto.UserResponse] "User unbanned"
// @Failure 400 {object} dto.ErrorResponse "bad request"
// @Failure 401 {object} dto.ErrorResponse "unauthorized"
// @Failure 403 {object} dto.ErrorResponse "forbidden"
// @Failure 404 {object} dto.ErrorResponse "not found"
// @Failure 409 {object} dto.ErrorResponse "confilct"
// @Failure 500 {object} dto.ErrorResponse "internal server error"
// @Router /admin/user/{id}/unban [patch]
func (h *UserHandler) UnbanUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Params("id")

        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">updatedUser, err := h.userService.UpdateUserBanStatus(userID, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(dto.Success(updatedUser.ToDTO()))</span>
}

// GetPending godoc
// @Summary Get all pending student verifications
// @Description Get all pending student verifications
// @Tags admin
// @Security Bearer
// @Produce json
// @Param limit query int false "Number of pending verification to retrieve (default 10, max 50)"
// @Param page query int false "Page number to retrieve (default 1)"
// @Success 200 {object} dto.PaginationResponse[dto.StudentEvidenceResponse] "All pending verification retrieved"
// @Failure 401 {object} dto.ErrorResponse "unauthorized"
// @Failure 403 {object} dto.ErrorResponse "forbidden"
// @Failure 404 {object} dto.ErrorResponse "not found"
// @Failure 500 {object} dto.ErrorResponse "internal server error"
// @Router /admin/lessee/pending [get]
func (h *UserHandler) GetPending(c *fiber.Ctx) error <span class="cov0" title="0">{
        limit := c.QueryInt("limit", 10)
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span> else<span class="cov0" title="0"> if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">page := c.QueryInt("page", 1)
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">pendings, totalPages, totalRows, err := h.userService.GetPending(limit, page)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data := make([]dto.StudentEvidenceResponse, len(pendings))
        for i, pending := range pendings </span><span class="cov0" title="0">{
                data[i].User = h.userService.ConvertToDTO(pending)

                evidence, err := h.userService.GetStudentEvidenceDTO(c.Context(), pending.StudentEvidence)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">data[i].Evidence = *evidence</span>
        }

        <span class="cov0" title="0">res := dto.SuccessPagination(data, dto.Pagination{
                CurrentPage: page,
                LastPage:    totalPages,
                Limit:       limit,
                Total:       totalRows,
        })

        return c.Status(fiber.StatusOK).JSON(res)</span>
}

func (h *UserHandler) ReviewStudentVerification(c *fiber.Ctx, status domain.VerificationStatus) error <span class="cov0" title="0">{
        id := c.Params("id")

        if err := uuid.Validate(id); err != nil </span><span class="cov0" title="0">{
                return apperror.BadRequestError(err, "Incorrect UUID format")
        }</span>

        <span class="cov0" title="0">lesseeID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Can not parse UUID")
        }</span>

        <span class="cov0" title="0">lessee, err := h.userService.UpdateVerificationStatus(lesseeID, status)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data := dto.StudentEvidenceResponse{}
        data.User = lessee.ToDTO()
        evidence, err := h.userService.GetStudentEvidenceDTO(c.Context(), lessee.StudentEvidence)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">data.Evidence = *evidence

        return c.Status(fiber.StatusOK).JSON(dto.Success(data))</span>
}

// VerifyStudentVerification godoc
// @Summary Verify a lessee student verification
// @Description Verify a lessee student verification
// @Tags admin
// @Security Bearer
// @Produce json
// @Param id path string true "lesseeID"
// @Success 200 {object} dto.SuccessResponse[dto.StudentEvidenceResponse] "Lessee verified"
// @Failure 400 {object} dto.ErrorResponse "bad request"
// @Failure 401 {object} dto.ErrorResponse "unauthorized"
// @Failure 403 {object} dto.ErrorResponse "forbidden"
// @Failure 404 {object} dto.ErrorResponse "not found"
// @Failure 409 {object} dto.ErrorResponse "confilct"
// @Failure 500 {object} dto.ErrorResponse "internal server error"
// @Router /admin/lessee/{id}/verify [patch]
func (h *UserHandler) VerifyStudentVerification(c *fiber.Ctx) error <span class="cov0" title="0">{
        return h.ReviewStudentVerification(c, domain.StatusVerified)
}</span>

// RejectStudentVerification godoc
// @Summary Reject a lessee student verification
// @Description Reject a lessee student verification
// @Tags admin
// @Security Bearer
// @Produce json
// @Param id path string true "lesseeID"
// @Success 200 {object} dto.SuccessResponse[dto.StudentEvidenceResponse] "Lessee rejected"
// @Failure 400 {object} dto.ErrorResponse "bad request"
// @Failure 401 {object} dto.ErrorResponse "unauthorized"
// @Failure 403 {object} dto.ErrorResponse "forbidden"
// @Failure 404 {object} dto.ErrorResponse "not found"
// @Failure 409 {object} dto.ErrorResponse "confilct"
// @Failure 500 {object} dto.ErrorResponse "internal server error"
// @Router /admin/lessee/{id}/reject [patch]
func (h *UserHandler) RejectStudentVerification(c *fiber.Ctx) error <span class="cov0" title="0">{
        return h.ReviewStudentVerification(c, domain.StatusRejected)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package middleware

import (
        "errors"
        "strings"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/pkg/jwt"
        "github.com/gofiber/fiber/v2"
        "github.com/yokeTH/go-pkg/apperror"
)

type AuthMiddleware struct {
        jwtUtils *jwt.JWTUtils
        userRepo ports.UserRepository
}

func NewAuthMiddleware(jwtUtils *jwt.JWTUtils, userRepo ports.UserRepository) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                jwtUtils: jwtUtils,
                userRepo: userRepo,
        }
}</span>

func (a *AuthMiddleware) Auth(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        authHeader := ctx.Get("Authorization")

        if authHeader == "" </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("request without authorization header"), "Authorization header is required")
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("invalid authorization header"), "Authorization header is invalid")
        }</span>

        <span class="cov0" title="0">token := authHeader[7:]
        userID, err := a.jwtUtils.VerifyAccessToken(ctx.Context(), token)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(err, "Invalid token")
        }</span>

        <span class="cov0" title="0">user, err := a.userRepo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(err, "User not found")
        }</span>

        <span class="cov0" title="0">if user.Banned </span><span class="cov0" title="0">{
                return apperror.ForbiddenError(errors.New("account banned"), "account banned")
        }</span>

        <span class="cov0" title="0">ctx.Locals("userID", userID)
        ctx.Locals("user", user)

        return ctx.Next()</span>
}

func (a *AuthMiddleware) RequireAdmin(c *fiber.Ctx) error <span class="cov0" title="0">{
        user := c.Locals("user").(*domain.User)
        if user.Role != domain.AdminRole </span><span class="cov0" title="0">{
                return apperror.ForbiddenError(errors.New("admin access required"), "Admin access required")
        }</span>
        <span class="cov0" title="0">return c.Next()</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package repository

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
        "gorm.io/gorm"
)

type ContractRepository struct {
        db *database.Database
}

func NewContractRepository(db *database.Database) ports.ContractRepository <span class="cov0" title="0">{
        return &amp;ContractRepository{db: db}
}</span>

func (ct *ContractRepository) Create(contract *domain.Contract) error <span class="cov0" title="0">{
        if err := ct.db.Create(contract).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to save contract to database")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ct *ContractRepository) Delete(contractID uuid.UUID) error <span class="cov0" title="0">{
        if err := ct.db.Where("id = ?", contractID).Delete(&amp;domain.Contract{}).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to delete contract")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ct *ContractRepository) GetContract(lesseeID uuid.UUID, dormID uuid.UUID) (*[]domain.Contract, error) <span class="cov0" title="0">{
        var contracts []domain.Contract
        if err := ct.db.
                Preload("Lessee").
                Preload("Dorm").
                Where("lessee_id = ? AND dorm_id = ?", lesseeID, dormID).
                Find(&amp;contracts).Error; err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, "Contracts not found")
        }</span>
        <span class="cov0" title="0">return &amp;contracts, nil</span>
}

func (ct *ContractRepository) GetContractByContractID(contractID uuid.UUID) (*domain.Contract, error) <span class="cov0" title="0">{
        contract := new(domain.Contract)
        if err := ct.db.
                Preload("Lessee").
                Preload("Dorm").
                Where("id = ? ", contractID).
                Find(&amp;contract).Error; err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, "Contract not found")
        }</span>
        <span class="cov0" title="0">return contract, nil</span>
}

func (ct *ContractRepository) GetContractByLessorID(lessorID uuid.UUID, limit, page int) (*[]domain.Contract, int, int, error) <span class="cov0" title="0">{
        var contracts []domain.Contract
        query := ct.db.
                Joins("JOIN dorms ON dorms.id = contracts.dorm_id").
                Where("dorms.owner_id = ?", lessorID).
                Preload("Lessee").
                Preload("Dorm").
                Find(&amp;contracts)

        totalPage, totalRows, err := ct.db.Paginate(&amp;contracts, query, limit, page, "create_at DESC")

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "contract not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to get contract")</span>
        }

        <span class="cov0" title="0">return &amp;contracts, totalPage, totalRows, nil</span>
}

func (ct *ContractRepository) GetContractByLesseeID(lesseeID uuid.UUID, limit, page int) (*[]domain.Contract, int, int, error) <span class="cov0" title="0">{
        var contracts []domain.Contract
        query := ct.db.
                Preload("Lessee").
                Preload("Dorm").
                Where("lessee_id = ? ", lesseeID).
                Find(&amp;contracts)

        totalPage, totalRows, err := ct.db.Paginate(&amp;contracts, query, limit, page, "create_at DESC")

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "contract not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to get contract")</span>
        }

        <span class="cov0" title="0">return &amp;contracts, totalPage, totalRows, nil</span>
}

func (ct *ContractRepository) GetContractByDormID(dormID uuid.UUID, limit, page int) (*[]domain.Contract, int, int, error) <span class="cov0" title="0">{
        var contracts []domain.Contract
        query := ct.db.
                Preload("Lessee").
                Preload("Dorm").
                Where("dorm_id = ? ", dormID).
                Find(&amp;contracts)

        totalPage, totalRows, err := ct.db.Paginate(&amp;contracts, query, limit, page, "create_at DESC")

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "contract not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to get contract")</span>
        }

        <span class="cov0" title="0">return &amp;contracts, totalPage, totalRows, nil</span>
}

func (ct *ContractRepository) UpdateStatus(contractID uuid.UUID, status domain.ContractStatus, role *domain.Role) error <span class="cov0" title="0">{
        if role == nil </span><span class="cov0" title="0">{
                contract := domain.Contract{
                        Status: status,
                }
                if err := ct.db.Model(&amp;domain.Contract{}).Where("id = ?",
                        contractID).Updates(contract).Error; err != nil </span><span class="cov0" title="0">{
                        return apperror.InternalServerError(err, "failed to update contract status")
                }</span>
        } else<span class="cov0" title="0"> if *role == domain.LessorRole </span><span class="cov0" title="0">{
                contract := domain.Contract{
                        LessorStatus: status,
                }
                if err := ct.db.Model(&amp;domain.Contract{}).Where("id = ?",
                        contractID).Updates(contract).Error; err != nil </span><span class="cov0" title="0">{
                        return apperror.InternalServerError(err, "failed to update lessor status")
                }</span>
        } else<span class="cov0" title="0"> if *role == domain.LesseeRole </span><span class="cov0" title="0">{
                contract := domain.Contract{
                        LesseeStatus: status,
                }
                if err := ct.db.Model(&amp;domain.Contract{}).Where("id = ?",
                        contractID).Updates(contract).Error; err != nil </span><span class="cov0" title="0">{
                        return apperror.InternalServerError(err, "failed to update lessee status")
                }</span>
        } else<span class="cov0" title="0"> {
                return apperror.InternalServerError(errors.New("invalid role"), "Invalid role")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package repository

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type DormRepository struct {
        db *database.Database
}

func NewDormRepository(db *database.Database) ports.DormRepository <span class="cov0" title="0">{
        return &amp;DormRepository{db: db}
}</span>

func (d *DormRepository) Create(dorm *domain.Dorm) error <span class="cov0" title="0">{
        if err := d.db.Create(dorm).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to save dorm to database")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *DormRepository) Delete(dorm domain.Dorm) error <span class="cov0" title="0">{
        // TODO: Cascade delete for all field that reference to dorm
        if err := d.db.Select("Images").Delete(&amp;dorm).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to delete dorm")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *DormRepository) GetAll(
        limit int, page int,
        search string,
        minPrice int, maxPrice int,
        district string,
        subdistrict string,
        province string,
        zipcode string,
) ([]domain.Dorm, int, int, error) <span class="cov0" title="0">{
        var dorms []domain.Dorm
        query := d.db.Preload("Owner").Preload("Images")

        if search != "" </span><span class="cov0" title="0">{
                regex := "%" + search + "%"
                query.Where("name ILIKE ? OR province ILIKE ? OR district ILIKE ? OR subdistrict ILIKE ? OR zipcode ILIKE ?", regex, regex, regex, regex, regex)
        }</span>

        <span class="cov0" title="0">if minPrice != -1 </span><span class="cov0" title="0">{
                query.Where("price &gt;= ?", minPrice)
        }</span>

        <span class="cov0" title="0">if maxPrice != -1 </span><span class="cov0" title="0">{
                query.Where("price &lt;= ?", maxPrice)
        }</span>

        <span class="cov0" title="0">if district != "" </span><span class="cov0" title="0">{
                query.Where("district ILIKE ?", "%"+district+"%")
        }</span>

        <span class="cov0" title="0">if subdistrict != "" </span><span class="cov0" title="0">{
                query.Where("subdistrict ILIKE ?", "%"+subdistrict+"%")
        }</span>

        <span class="cov0" title="0">if province != "" </span><span class="cov0" title="0">{
                query.Where("province ILIKE ?", "%"+province+"%")
        }</span>

        <span class="cov0" title="0">if zipcode != "" </span><span class="cov0" title="0">{
                query.Where("zipcode ILIKE ?", "%"+zipcode+"%")
        }</span>

        <span class="cov0" title="0">totalPages, totalRows, err := d.db.Paginate(&amp;dorms, query, limit, page, "create_at DESC")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, 0, apperror.InternalServerError(err, "Failed to retrieve dorms")
        }</span>

        <span class="cov0" title="0">return dorms, totalPages, totalRows, nil</span>
}

func (d *DormRepository) GetByID(id uuid.UUID) (*domain.Dorm, error) <span class="cov0" title="0">{
        dorm := new(domain.Dorm)
        if err := d.db.Preload("Owner").Preload("Images").First(dorm, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, "Dorm not found")
        }</span>
        <span class="cov0" title="0">return dorm, nil</span>
}

func (d *DormRepository) Update(id uuid.UUID, dorm dto.DormUpdateRequestBody) error <span class="cov0" title="0">{
        updatedDorm := domain.Dorm{
                Name:        dorm.Name,
                Size:        dorm.Size,
                Bedrooms:    dorm.Bedrooms,
                Bathrooms:   dorm.Bathrooms,
                Address:     domain.Address(dorm.Address),
                Price:       dorm.Price,
                Description: dorm.Description,
        }

        res := d.db.Model(&amp;domain.Dorm{}).Where("id = ?", id).Updates(updatedDorm)
        if res.Error != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(res.Error, "Failed to update room")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (d *DormRepository) SaveDormImage(dormImage *domain.DormImage) error <span class="cov0" title="0">{
        if err := d.db.Create(dormImage).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to save dorm's image to database")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *DormRepository) GetByOwnerID(ownerID uuid.UUID, limit int, page int) ([]domain.Dorm, int, int, error) <span class="cov0" title="0">{
        var dorms []domain.Dorm
        query := d.db.Preload("Owner").Preload("Images").Where("owner_id = ?", ownerID)

        totalPages, totalRows, err := d.db.Paginate(&amp;dorms, query, limit, page, "create_at DESC")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, 0, apperror.InternalServerError(err, "Failed to retrieve dorms")
        }</span>

        <span class="cov0" title="0">return dorms, totalPages, totalRows, nil</span>
}

func (d *DormRepository) DeleteImageByKey(imageKey string) error <span class="cov0" title="0">{
        if err := d.db.Where("image_key = ?", imageKey).Delete(&amp;domain.DormImage{}).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to delete image")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *DormRepository) GetImageByKey(imageKey string) (*domain.DormImage, error) <span class="cov0" title="0">{
        dormImage := new(domain.DormImage)
        if err := d.db.Where("image_key = ?", imageKey).First(dormImage).Error; err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, "Image not found")
        }</span>
        <span class="cov0" title="0">return dormImage, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package repository

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
        "gorm.io/gorm"
)

type LeasingHistoryRepository struct {
        db *database.Database
}

func NewLeasingHistoryRepository(db *database.Database) ports.LeasingHistoryRepository <span class="cov0" title="0">{
        return &amp;LeasingHistoryRepository{db: db}
}</span>

func (d *LeasingHistoryRepository) Create(LeasingHistory *domain.LeasingHistory) error <span class="cov0" title="0">{
        if err := d.db.Create(LeasingHistory).Error; err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "failed to save leasing history to database")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (d *LeasingHistoryRepository) GetByID(id uuid.UUID) (*domain.LeasingHistory, error) <span class="cov0" title="0">{
        leasingHistory := new(domain.LeasingHistory)
        if err := d.db.
                Preload("Dorm").
                Preload("Lessee").
                Preload("Orders").
                Preload("Dorm.Owner").
                Preload("Images").
                First(leasingHistory, id).Error; err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, apperror.NotFoundError(err, "leasing history not found")</span>
        }
        <span class="cov0" title="0">return leasingHistory, nil</span>
}

func (d *LeasingHistoryRepository) Update(LeasingHistory *domain.LeasingHistory) error <span class="cov0" title="0">{
        existingHistory, err := d.GetByID(LeasingHistory.ID)
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.NotFoundError(err, "History not found")</span>
        }
        <span class="cov0" title="0">err = d.db.Model(existingHistory).Updates(LeasingHistory).Error
        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "Failed to update leasing history")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (d *LeasingHistoryRepository) SaveReviewImage(reviewImage *domain.ReviewImage) error <span class="cov0" title="0">{
        if err := d.db.Create(reviewImage).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to save review's image to database")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *LeasingHistoryRepository) DeleteImageByKey(imageKey string) error <span class="cov0" title="0">{
        if err := d.db.Where("image_key = ?", imageKey).Delete(&amp;domain.ReviewImage{}).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to delete image")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *LeasingHistoryRepository) GetImageByKey(imageKey string) (*domain.ReviewImage, error) <span class="cov0" title="0">{
        reviewImage := new(domain.ReviewImage)
        if err := d.db.Where("image_key = ?", imageKey).First(reviewImage).Error; err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, "Image not found")
        }</span>
        <span class="cov0" title="0">return reviewImage, nil</span>
}

func (d *LeasingHistoryRepository) DeleteReview(leasingHistory *domain.LeasingHistory) error <span class="cov0" title="0">{
        err := d.db.Model(leasingHistory).Update("review_flag", false).Error
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to delete review")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *LeasingHistoryRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        // TODO: Cascade delete?
        if err := d.db.Delete(&amp;domain.LeasingHistory{}, id).Error; err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return apperror.InternalServerError(err, "Failed to delete leasing history")</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (d *LeasingHistoryRepository) GetByUserID(id uuid.UUID, limit, page int) ([]domain.LeasingHistory, int, int, error) <span class="cov0" title="0">{
        var leasingHistory []domain.LeasingHistory
        query := d.db.Preload("Dorm").
                Preload("Lessee").
                Preload("Orders").
                Preload("Dorm.Owner").
                Preload("Images").
                Where("lessee_id = ?", id)
        totalPage, totalRows, err := d.db.Paginate(&amp;leasingHistory, query, limit, page, "start")

        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return nil, 0, 0, err
                }</span>
                <span class="cov0" title="0">if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "leasing history not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to get leasing history")</span>
        }

        <span class="cov0" title="0">return leasingHistory, totalPage, totalRows, nil</span>
}
func (d *LeasingHistoryRepository) GetByDormID(id uuid.UUID, limit, page int) ([]domain.LeasingHistory, int, int, error) <span class="cov0" title="0">{
        var leasingHistory []domain.LeasingHistory
        query := d.db.Preload("Dorm").
                Preload("Dorm.Owner").
                Preload("Images").
                Where("dorm_id = ?", id)
        totalPage, totalRows, err := d.db.Paginate(&amp;leasingHistory, query, limit, page, "start")

        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return nil, 0, 0, err
                }</span>
                <span class="cov0" title="0">if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "leasing history not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to get leasing history")</span>
        }

        <span class="cov0" title="0">return leasingHistory, totalPage, totalRows, nil</span>
}

func (d *LeasingHistoryRepository) GetReviewByDormID(id uuid.UUID, limit, page int) ([]domain.LeasingHistory, int, int, error) <span class="cov0" title="0">{
        var reviews []domain.LeasingHistory
        query := d.db.Preload("Lessee").
                Preload("Dorm").
                Preload("Images").
                Where("review_flag = ?", true).
                Where("dorm_id = ?", id)
        totalPage, totalRows, err := d.db.Paginate(&amp;reviews, query, limit, page, "start")

        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return nil, 0, 0, err
                }</span>
                <span class="cov0" title="0">if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "Review not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to get reviews")</span>
        }

        <span class="cov0" title="0">return reviews, totalPage, totalRows, nil</span>
}

func (d *LeasingHistoryRepository) GetReportedReviews(limit int, page int) ([]domain.LeasingHistory, int, int, error) <span class="cov0" title="0">{
        var reviews []domain.LeasingHistory
        query := d.db.Preload("Lessee").Preload("Images").Where("report_flag = ?", true).Where("review_flag = ?", true)
        totalPages, totalRows, err := d.db.Paginate(&amp;reviews, query, limit, page, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, 0, apperror.InternalServerError(err, "Failed to retrieve reviews")
        }</span>
        <span class="cov0" title="0">return reviews, totalPages, totalRows, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package repository

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
        "gorm.io/gorm"
)

type LeasingRequestRepository struct {
        db *database.Database
}

func NewLeasingRequestRepository(db *database.Database) ports.LeasingRequestRepository <span class="cov0" title="0">{
        return &amp;LeasingRequestRepository{db: db}
}</span>

func (d *LeasingRequestRepository) Create(LeasingRequest *domain.LeasingRequest) error <span class="cov0" title="0">{
        if err := d.db.Create(LeasingRequest).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to save leasing request to database")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (d *LeasingRequestRepository) GetByID(id uuid.UUID) (*domain.LeasingRequest, error) <span class="cov0" title="0">{
        leasingRequest := new(domain.LeasingRequest)
        if err := d.db.Preload("Dorm").Preload("Lessee").Preload("Dorm.Owner").First(leasingRequest, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, "leasing request not found")
        }</span>
        <span class="cov0" title="0">return leasingRequest, nil</span>
}

func (d *LeasingRequestRepository) Update(LeasingRequest *domain.LeasingRequest) error <span class="cov0" title="0">{
        existingRequest, err := d.GetByID(LeasingRequest.ID)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.NotFoundError(err, "leasing request not found")
        }</span>
        <span class="cov0" title="0">err = d.db.Model(existingRequest).Updates(LeasingRequest).Error
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to update leasing request")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (d *LeasingRequestRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        if err := d.db.Delete(&amp;domain.LeasingRequest{}, id).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to delete leasing request")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (d *LeasingRequestRepository) GetByUserID(id uuid.UUID, limit, page int, role domain.Role) ([]domain.LeasingRequest, int, int, error) <span class="cov0" title="0">{
        var leasingRequest []domain.LeasingRequest
        var query *gorm.DB
        if role == domain.LesseeRole </span><span class="cov0" title="0">{
                query = d.db.Preload("Dorm").
                        Preload("Lessee").
                        Preload("Dorm.Owner").
                        Where("lessee_id = ?", id)
        }</span> else<span class="cov0" title="0"> if role == domain.LessorRole </span><span class="cov0" title="0">{
                query = d.db.Preload("Dorm").
                        Preload("Lessee").
                        Preload("Dorm.Owner").
                        Joins("JOIN dorms ON dorms.id = leasing_requests.dorm_id").
                        Where("owner_id = ?", id)
        }</span> else<span class="cov0" title="0"> {
                query = d.db.Preload("Dorm").
                        Preload("Lessee").
                        Preload("Dorm.Owner").
                        Joins("LEFT JOIN dorms ON dorms.id = leasing_requests.dorm_id").
                        Where("lessee_id = ? OR owner_id = ?", id, id)
        }</span>
        <span class="cov0" title="0">totalPage, totalRows, err := d.db.Paginate(&amp;leasingRequest, query, limit, page, "start DESC")

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "leasing request not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to get leasing request")</span>
        }

        <span class="cov0" title="0">return leasingRequest, totalPage, totalRows, nil</span>
}

func (d *LeasingRequestRepository) GetByDormID(id uuid.UUID, limit, page int) ([]domain.LeasingRequest, int, int, error) <span class="cov0" title="0">{
        var leasingRequest []domain.LeasingRequest
        query := d.db.Preload("Dorm").Preload("Dorm.Owner").Preload("Lessee").Where("dorm_id = ?", id)
        totalPage, totalRows, err := d.db.Paginate(&amp;leasingRequest, query, limit, page, "start")

        if err != nil </span><span class="cov0" title="0">{
                if apperror.IsAppError(err) </span><span class="cov0" title="0">{
                        return nil, 0, 0, err
                }</span>
                <span class="cov0" title="0">if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "leasing history not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to get leasing history")</span>
        }

        <span class="cov0" title="0">return leasingRequest, totalPage, totalRows, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package repository

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
        "gorm.io/gorm"
)

type OrderRepository struct {
        db *database.Database
}

func NewOrderRepository(db *database.Database) ports.OrderRepository <span class="cov0" title="0">{
        return &amp;OrderRepository{
                db: db,
        }
}</span>

func (r *OrderRepository) Create(order *domain.Order) error <span class="cov0" title="0">{
        if err := r.db.Create(order).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to create order")
        }</span>

        <span class="cov0" title="0">if err := r.db.Preload("LeasingHistory").First(order, order.ID).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to preload leasing history")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *OrderRepository) GetByID(orderID uuid.UUID) (*domain.Order, error) <span class="cov0" title="0">{
        var order domain.Order
        if err := r.db.
                Where("id = ?", orderID).
                Preload("LeasingHistory").
                Preload("LeasingHistory.Dorm").
                Preload("LeasingHistory.Lessee").
                Preload("PaidTransaction").
                First(&amp;order).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, apperror.NotFoundError(err, "order not found")
                }</span>
                <span class="cov0" title="0">return nil, apperror.InternalServerError(err, "database error retrieving order")</span>
        }
        <span class="cov0" title="0">return &amp;order, nil</span>
}

func (r *OrderRepository) GetUnpaidByUserID(userID uuid.UUID, limit int, page int) ([]domain.Order, int, int, error) <span class="cov0" title="0">{
        var orders []domain.Order
        query := r.db.
                Joins("JOIN leasing_histories ON leasing_histories.id = orders.leasing_history_id").
                Where("leasing_histories.lessee_id = ?", userID).
                Where("orders.paid_transaction_id IS NULL")

        totalPage, totalRows, err := r.db.Paginate(&amp;orders, query, limit, page, "create_at desc")
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "order not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to orders")</span>
        }

        <span class="cov0" title="0">return orders, totalPage, totalRows, nil</span>
}

func (r *OrderRepository) Update(order *domain.Order) error <span class="cov0" title="0">{
        if err := r.db.Model(order).Where("id = ?", order.ID).Updates(order).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to update order")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *OrderRepository) Delete(orderID uuid.UUID) error <span class="cov0" title="0">{
        if err := r.db.Where("id = ?", orderID).Delete(&amp;domain.Order{}).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to delete order")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package repository

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/PitiNarak/condormhub-backend/internal/dto"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type OwnershipProofRepository struct {
        db *database.Database
}

func NewOwnershipProofRepository(db *database.Database) ports.OwnershipProofRepository <span class="cov0" title="0">{
        return &amp;OwnershipProofRepository{db: db}
}</span>

func (o *OwnershipProofRepository) Create(ownershipProof *domain.OwnershipProof) error <span class="cov0" title="0">{
        if err := o.db.Create(ownershipProof).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to save ownership proof to database")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *OwnershipProofRepository) Delete(dormID uuid.UUID) error <span class="cov0" title="0">{
        if err := o.db.Delete(&amp;domain.OwnershipProof{}, dormID).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to delete ownership proof")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *OwnershipProofRepository) GetByDormID(dormID uuid.UUID) (*domain.OwnershipProof, error) <span class="cov0" title="0">{
        ownershipProof := new(domain.OwnershipProof)
        if err := o.db.First(ownershipProof, dormID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, "Ownership proof not found")
        }</span>
        <span class="cov0" title="0">return ownershipProof, nil</span>
}

func (o *OwnershipProofRepository) UpdateDocument(dormID uuid.UUID, fileKey string) error <span class="cov0" title="0">{
        if err := o.db.Model(&amp;domain.OwnershipProof{}).Where("dorm_id = ?", dormID).Updates(map[string]interface{}{"file_key": fileKey}).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to update document")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *OwnershipProofRepository) UpdateStatus(dormID uuid.UUID, updateStatusRequestBody *dto.UpdateOwnerShipProofStatusRequestBody) error <span class="cov0" title="0">{
        if err := o.db.Model(&amp;domain.OwnershipProof{}).Where("dorm_id = ?", dormID).Updates(updateStatusRequestBody).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to update status")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package repository

import (
        "errors"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
        "gorm.io/gorm"
)

type ReceiptRepository struct {
        db *database.Database
}

func NewReceiptRepository(db *database.Database) ports.ReceiptRepository <span class="cov0" title="0">{
        return &amp;ReceiptRepository{db: db}
}</span>

func (r *ReceiptRepository) Create(receipt *domain.Receipt) error <span class="cov0" title="0">{
        if err := r.db.Create(receipt).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to create receipt")
        }</span>

        <span class="cov0" title="0">if err := r.db.Preload("Owner").Preload("Transaction").First(receipt, receipt.ID).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to preload receipt")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ReceiptRepository) GetByUserID(userID uuid.UUID, limit int, page int) ([]domain.Receipt, int, int, error) <span class="cov0" title="0">{
        var receipts []domain.Receipt
        query := r.db.Preload("Owner").
                Preload("Transaction").
                Where("owner_id = ?", userID).
                Find(&amp;receipts)

        totalPage, totalRows, err := r.db.Paginate(&amp;receipts, query, limit, page, "create_at DESC")
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, 0, apperror.NotFoundError(err, "receipt not found")
                }</span>
                <span class="cov0" title="0">return nil, 0, 0, apperror.InternalServerError(err, "failed to receipts")</span>
        }

        <span class="cov0" title="0">return receipts, totalPage, totalRows, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package repository

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/google/uuid"
)

type SampleLogRepository struct {
        db *database.Database
}

func NewSampleLogRepository(db *database.Database) *SampleLogRepository <span class="cov0" title="0">{
        return &amp;SampleLogRepository{
                db: db,
        }
}</span>

func (r *SampleLogRepository) Save(message string) error <span class="cov0" title="0">{
        if err := r.db.Create(&amp;domain.SampleLog{
                Message: message,
        }).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *SampleLogRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;domain.SampleLog{}, "id = ?", id).Error
}</span>

func (r *SampleLogRepository) GetAll() ([]domain.SampleLog, error) <span class="cov0" title="0">{
        var logs []domain.SampleLog
        err := r.db.Find(&amp;logs).Error
        return logs, err
}</span>

func (r *SampleLogRepository) EditMessage(id uuid.UUID, message string) error <span class="cov0" title="0">{
        return r.db.Model(&amp;domain.SampleLog{}).Where("id = ?", id).Update("message", message).Error
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package repository

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type SupportRepository struct {
        db *database.Database
}

func NewSupportRepository(db *database.Database) ports.SupportRepository <span class="cov0" title="0">{
        return &amp;SupportRepository{db: db}
}</span>

func (s *SupportRepository) Create(support *domain.SupportRequest) error <span class="cov0" title="0">{
        if err := s.db.Create(support).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Could not submit support request")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *SupportRepository) GetAll(limit int, page int, userID uuid.UUID, isAdmin bool) ([]domain.SupportRequest, int, int, error) <span class="cov0" title="0">{
        var supports []domain.SupportRequest

        // If current user is an admin retrieve all, otherwise retrieve only support the user created
        query := s.db.DB
        if !isAdmin </span><span class="cov0" title="0">{
                query = query.Where("user_id = ?", userID)
        }</span>

        <span class="cov0" title="0">totalPages, totalRows, err := s.db.Paginate(&amp;supports, query, limit, page, "update_at DESC")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, 0, apperror.InternalServerError(err, "Could not fetch support requests")
        }</span>
        <span class="cov0" title="0">return supports, totalPages, totalRows, nil</span>
}

func (s *SupportRepository) GetByID(id uuid.UUID) (*domain.SupportRequest, error) <span class="cov0" title="0">{
        support := new(domain.SupportRequest)
        if err := s.db.First(support, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(err, "Support request not found")
        }</span>
        <span class="cov0" title="0">return support, nil</span>
}

func (s *SupportRepository) UpdateStatus(id uuid.UUID, status domain.SupportStatus) error <span class="cov0" title="0">{
        if err := s.db.Model(&amp;domain.SupportRequest{}).Where("id = ?", id).Update("status", status).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Could not update support request status")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package repository

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/yokeTH/go-pkg/apperror"
)

type TransactionRepository struct {
        db *database.Database
}

func NewTransactionRepository(db *database.Database) ports.TransactionRepository <span class="cov0" title="0">{
        return &amp;TransactionRepository{db: db}
}</span>

func (r *TransactionRepository) Create(tsx *domain.Transaction) error <span class="cov0" title="0">{
        err := r.db.Create(tsx).Error
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to create order")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *TransactionRepository) Update(tsx *domain.Transaction) error <span class="cov0" title="0">{
        err := r.db.Model(&amp;tsx).Where("id = ?", tsx.ID).Updates(tsx).Error
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "Failed to create order")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *TransactionRepository) GetByID(id string) (domain.Transaction, error) <span class="cov0" title="0">{
        var tsx domain.Transaction
        err := r.db.Where("id = ?", id).First(&amp;tsx).Error
        if err != nil </span><span class="cov0" title="0">{
                return tsx, apperror.NotFoundError(err, "Transaction not found")
        }</span>
        <span class="cov0" title="0">return tsx, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package repository

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/yokeTH/go-pkg/apperror"

        "github.com/google/uuid"
)

type UserRepo struct {
        db *database.Database
}

func NewUserRepo(db *database.Database) ports.UserRepository <span class="cov0" title="0">{
        return &amp;UserRepo{db: db}
}</span>

func (r *UserRepo) Create(user *domain.User) error <span class="cov0" title="0">{

        exitsUser := r.db.Model(&amp;domain.User{}).Where("username = ?", user.Username).Or("email = ?", user.Email).First(&amp;domain.User{})
        if exitsUser.RowsAffected &gt; 0 </span><span class="cov0" title="0">{
                return apperror.BadRequestError(nil, "username already exists or email already exists")
        }</span>

        <span class="cov0" title="0">err := r.db.Create(&amp;user).Error

        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to save user to database")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *UserRepo) GetUserByEmail(email string) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        result := r.db.Where("email = ?", email).First(&amp;user)

        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(result.Error, "user not found")
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *UserRepo) GetUserByID(userID uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        result := r.db.Where("id = ?", userID).First(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, apperror.NotFoundError(result.Error, "user not found")
        }</span>
        <span class="cov0" title="0">return &amp;user, result.Error</span>
}

func (r *UserRepo) UpdateUser(user *domain.User) error <span class="cov0" title="0">{
        result := r.db.Model(&amp;user).Save(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(result.Error, "failed to update database")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *UserRepo) UpdateInformation(userID uuid.UUID, data domain.User) error <span class="cov0" title="0">{

        if err := r.db.Model(&amp;domain.User{}).Where("id = ?", userID).Updates(data).Error; err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "failed to update user information")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *UserRepo) DeleteAccount(userID uuid.UUID) error <span class="cov0" title="0">{
        user := domain.User{ID: userID}
        result := r.db.Delete(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(result.Error, "cannot delete user")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *UserRepo) GetLessorIncome(lessorID uuid.UUID) (float64, error) <span class="cov0" title="0">{
        var income float64
        err := r.db.Model(&amp;domain.LeasingHistory{}).Joins("JOIN dorms ON dorms.id = leasing_histories.dorm_id").
                Where("dorms.owner_id = ?", lessorID).
                Where("leasing_histories.end IS NULL").
                Select("COALESCE(SUM(leasing_histories.price), 0)").
                Scan(&amp;income).Error
        if err != nil </span><span class="cov0" title="0">{
                return 0, apperror.InternalServerError(err, "failed to calculate lessor's income")
        }</span>
        <span class="cov0" title="0">return income, nil</span>
}

func (r *UserRepo) GetPending(limit int, page int) ([]domain.User, int, int, error) <span class="cov0" title="0">{
        var pending []domain.User
        query := r.db.Where("is_student_verified = ?", domain.StatusPending)

        totalPages, totalRows, err := r.db.Paginate(&amp;pending, query, limit, page, "update_at DESC")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, 0, apperror.InternalServerError(err, "Failed to load lessee with pending verification")
        }</span>
        <span class="cov0" title="0">return pending, totalPages, totalRows, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package server

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        handler1 "github.com/PitiNarak/condormhub-backend/internal/handler"
)

type handler struct {
        greeting       *handler1.GreetingHandler
        user           ports.UserHandler
        exampleUpload  *handler1.TestUploadHandler
        dorm           ports.DormHandler
        leasingHistory ports.LeasingHistoryHandler
        order          ports.OrderHandler
        tsx            ports.TransactionHandler
        ownershipProof ports.OwnershipProofHandler
        contract       ports.ContractHandler
        leasingRequest ports.LeasingRequestHandler
        receipt        ports.ReceiptHandler
        support        ports.SupportHandler
}

func (s *Server) initHandler() <span class="cov0" title="0">{
        greeting := handler1.NewGreetingHandler()
        user := handler1.NewUserHandler(s.service.user)
        exampleUpload := handler1.NewTestUploadHandler(s.storage)
        dorm := handler1.NewDormHandler(s.service.dorm)
        leasingHistory := handler1.NewLeasingHistoryHandler(s.service.leasingHistory, s.service.dorm)
        order := handler1.NewOrderHandler(s.service.order)
        tsx := handler1.NewTransactionHandler(s.service.tsx, s.stripeConfig)
        ownershipProof := handler1.NewOwnershipProofHandler(s.service.ownershipProof, s.storage)
        contract := handler1.NewContractHandler(s.service.contract)
        leasingRequest := handler1.NewLeasingRequestHandler(s.service.leasingRequest)
        receipt := handler1.NewReceiptHandler(s.service.receipt)
        support := handler1.NewSupportHandler(s.service.support)

        s.handler = &amp;handler{
                greeting:       greeting,
                user:           user,
                exampleUpload:  exampleUpload,
                dorm:           dorm,
                leasingHistory: leasingHistory,
                order:          order,
                tsx:            tsx,
                ownershipProof: ownershipProof,
                contract:       contract,
                leasingRequest: leasingRequest,
                receipt:        receipt,
                support:        support,
        }
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package server

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        repository1 "github.com/PitiNarak/condormhub-backend/internal/repository"
)

type repository struct {
        user           ports.UserRepository
        dorm           ports.DormRepository
        leasingHistory ports.LeasingHistoryRepository
        order          ports.OrderRepository
        tsx            ports.TransactionRepository
        ownershipProof ports.OwnershipProofRepository
        contract       ports.ContractRepository
        leasingRequest ports.LeasingRequestRepository
        receipt        ports.ReceiptRepository
        support        ports.SupportRepository
}

func (s *Server) initRepository() <span class="cov0" title="0">{
        user := repository1.NewUserRepo(s.db)
        dorm := repository1.NewDormRepository(s.db)
        leasingHistory := repository1.NewLeasingHistoryRepository(s.db)
        order := repository1.NewOrderRepository(s.db)
        tsx := repository1.NewTransactionRepository(s.db)
        ownershipProof := repository1.NewOwnershipProofRepository(s.db)
        contract := repository1.NewContractRepository(s.db)
        leasingRequest := repository1.NewLeasingRequestRepository(s.db)
        receipt := repository1.NewReceiptRepository(s.db)
        support := repository1.NewSupportRepository(s.db)

        s.repository = &amp;repository{
                user:           user,
                dorm:           dorm,
                leasingHistory: leasingHistory,
                order:          order,
                tsx:            tsx,
                ownershipProof: ownershipProof,
                contract:       contract,
                leasingRequest: leasingRequest,
                receipt:        receipt,
                support:        support,
        }
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package server

import (
        "github.com/yokeTH/go-pkg/scalar"
)

func (s *Server) initRoutes() <span class="cov0" title="0">{
        // greeting
        s.app.Get("/", s.handler.greeting.Greeting)

        // swagger
        s.app.Get("/swagger/*", scalar.DefaultHandler)

        s.initExampleUploadRoutes()
        s.initUserRoutes()
        s.initAuthRoutes()
        s.initDormRoutes()
        s.initLeasingHistoryRoutes()
        s.initLeasingRequestRoutes()
        s.initOrderRoutes()
        s.initTransactionRoutes()
        s.initOwnershipProofRoutes()
        s.initReceiptRoutes()
        s.initContractRoutes()
        s.initSupportRoutes()
        s.initAdminRoutes()
}</span>

func (s *Server) initExampleUploadRoutes() <span class="cov0" title="0">{
        s.app.Post("/upload/public", s.handler.exampleUpload.UploadToPublicBucketHandler)
        s.app.Post("/upload/private", s.handler.exampleUpload.UploadToPrivateBucketHandler)
        s.app.Get("/signedurl/*", s.handler.exampleUpload.GetSignedUrlHandler)
}</span>

func (s *Server) initUserRoutes() <span class="cov0" title="0">{
        userRoutes := s.app.Group("/user")

        userRoutes.Get("/me", s.authMiddleware.Auth, s.handler.user.GetUserInfo)
        userRoutes.Get("/income", s.authMiddleware.Auth, s.handler.user.GetLessorIncome)
        userRoutes.Get("/:id", s.authMiddleware.Auth, s.handler.user.GetUserByID)

        userRoutes.Post("/verify", s.handler.user.VerifyEmail)
        userRoutes.Post("/resetpassword", s.handler.user.ResetPasswordCreate)
        userRoutes.Post("/newpassword", s.handler.user.ResetPassword)
        userRoutes.Post("/resend", s.handler.user.ResendVerificationEmailHandler)

        userRoutes.Patch("/firstfill", s.authMiddleware.Auth, s.handler.user.FirstFillInformation)
        userRoutes.Patch("/", s.authMiddleware.Auth, s.handler.user.UpdateUserInformation)
        userRoutes.Delete("/", s.authMiddleware.Auth, s.handler.user.DeleteAccount)

        userRoutes.Post("/studentEvidence", s.authMiddleware.Auth, s.handler.user.UploadStudentEvidence)
        userRoutes.Get("/:id/studentEvidence", s.authMiddleware.Auth, s.handler.user.GetStudentEvidenceByID)

        userRoutes.Post("/profilePic", s.authMiddleware.Auth, s.handler.user.UploadProfilePicture)
}</span>

func (s *Server) initAuthRoutes() <span class="cov0" title="0">{
        authRoutes := s.app.Group("/auth")
        authRoutes.Post("/register", s.handler.user.Register)
        authRoutes.Post("/login", s.handler.user.Login)
        authRoutes.Post("/refresh", s.handler.user.RefreshToken)
}</span>

func (s *Server) initDormRoutes() <span class="cov0" title="0">{
        // dorm
        dormRoutes := s.app.Group("/dorms")
        dormRoutes.Post("/", s.authMiddleware.Auth, s.handler.dorm.Create)
        dormRoutes.Get("/", s.handler.dorm.GetAll)
        dormRoutes.Get("/:id", s.handler.dorm.GetByID)
        dormRoutes.Patch("/:id", s.authMiddleware.Auth, s.handler.dorm.Update)
        dormRoutes.Delete("/images/:url", s.authMiddleware.Auth, s.handler.dorm.DeleteDormImageByURL)
        dormRoutes.Delete("/:id", s.authMiddleware.Auth, s.handler.dorm.Delete)
        dormRoutes.Post("/:id/images", s.authMiddleware.Auth, s.handler.dorm.UploadDormImage)
        dormRoutes.Get("/owner/:id", s.handler.dorm.GetByOwnerID)
}</span>

func (s *Server) initLeasingHistoryRoutes() <span class="cov0" title="0">{
        s.app.Get("/history/bydorm/:id/review", s.handler.leasingHistory.GetReviewByDormID)
        historyRoutes := s.app.Group("/history", s.authMiddleware.Auth)
        historyRoutes.Post("/:id/review", s.handler.leasingHistory.CreateReview)
        historyRoutes.Patch("/:id/review", s.handler.leasingHistory.UpdateReview)
        historyRoutes.Delete("/:id/review", s.handler.leasingHistory.DeleteReview)
        historyRoutes.Post("/:id/review/image", s.handler.leasingHistory.UploadReviewImage)
        historyRoutes.Delete("/review/image/:url", s.handler.leasingHistory.DeleteReviewImageByURL)
        historyRoutes.Get("/me", s.handler.leasingHistory.GetByUserID)
        historyRoutes.Get("/bydorm/:id", s.handler.leasingHistory.GetByDormID)
        historyRoutes.Get("/:id", s.handler.leasingHistory.GetByID)
        historyRoutes.Patch("/:id", s.handler.leasingHistory.SetEndTimestamp)
        historyRoutes.Delete("/:id", s.handler.leasingHistory.Delete)
        historyRoutes.Post("/:id/review/report", s.handler.leasingHistory.ReportReview)
}</span>

func (s *Server) initLeasingRequestRoutes() <span class="cov0" title="0">{
        requestRoutes := s.app.Group("/request", s.authMiddleware.Auth)
        requestRoutes.Post("/:id", s.handler.leasingRequest.Create)
        requestRoutes.Get("/me", s.handler.leasingRequest.GetByUserID)
        requestRoutes.Patch("/:id/approve", s.handler.leasingRequest.Approve)
        requestRoutes.Patch("/:id/reject", s.handler.leasingRequest.Reject)
        requestRoutes.Patch("/:id/cancel", s.handler.leasingRequest.Cancel)
        requestRoutes.Delete("/:id", s.authMiddleware.RequireAdmin, s.handler.leasingRequest.Delete)
        requestRoutes.Get("/bydorm/:id", s.handler.leasingRequest.GetByDormID)
}</span>

func (s *Server) initOrderRoutes() <span class="cov0" title="0">{
        orderRoutes := s.app.Group("/order", s.authMiddleware.Auth)
        orderRoutes.Post("/", s.handler.order.CreateOrder)
        orderRoutes.Get("/:id", s.handler.order.GetOrderByID)
        orderRoutes.Get("/unpaid/me", s.handler.order.GetMyUnpaidOrder)
        orderRoutes.Get("/unpaid/:id", s.handler.order.GetUnpaidOrderByUserID)
}</span>

func (s *Server) initTransactionRoutes() <span class="cov0" title="0">{
        tsxRoutes := s.app.Group("/transaction")
        tsxRoutes.Post("/", s.authMiddleware.Auth, s.handler.tsx.CreateTransaction)
        tsxRoutes.Post("/webhook", s.handler.tsx.Webhook)
}</span>

func (s *Server) initOwnershipProofRoutes() <span class="cov0" title="0">{
        ownershipRoutes := s.app.Group("/ownership")
        ownershipRoutes.Post("/:id/upload", s.authMiddleware.Auth, s.handler.ownershipProof.UploadFile)
        ownershipRoutes.Delete("/:id", s.authMiddleware.Auth, s.handler.ownershipProof.Delete)
        ownershipRoutes.Get("/:id", s.handler.ownershipProof.GetByDormID)
        ownershipRoutes.Post("/:id/approve", s.authMiddleware.Auth, s.authMiddleware.RequireAdmin, s.handler.ownershipProof.Approve)
        ownershipRoutes.Post("/:id/reject", s.authMiddleware.Auth, s.authMiddleware.RequireAdmin, s.handler.ownershipProof.Reject)

}</span>

func (s *Server) initReceiptRoutes() <span class="cov0" title="0">{
        receiptRoutes := s.app.Group("/receipt", s.authMiddleware.Auth)
        receiptRoutes.Get("/", s.handler.receipt.GetByUserID)
}</span>

func (s *Server) initContractRoutes() <span class="cov0" title="0">{
        contractRoutes := s.app.Group("/contract", s.authMiddleware.Auth)
        contractRoutes.Patch("/:contractID/sign", s.handler.contract.SignContract)
        contractRoutes.Patch("/:contractID/cancel", s.handler.contract.CancelContract)
        contractRoutes.Get("/:contractID", s.handler.contract.GetContractByContractID)
        contractRoutes.Get("/", s.handler.contract.GetContractByUserID)
        contractRoutes.Get("/:dormID", s.handler.contract.GetContractByDormID)
        contractRoutes.Delete("/:contractID", s.handler.contract.Delete)

}</span>

func (s *Server) initSupportRoutes() <span class="cov0" title="0">{
        supportRoutes := s.app.Group("/support", s.authMiddleware.Auth)
        supportRoutes.Post("/", s.handler.support.Create)
        supportRoutes.Get("/", s.handler.support.GetAll)
        supportRoutes.Patch("/:id", s.authMiddleware.RequireAdmin, s.handler.support.UpdateStatus)
}</span>

func (s *Server) initAdminRoutes() <span class="cov0" title="0">{
        adminRoutes := s.app.Group("/admin", s.authMiddleware.Auth, s.authMiddleware.RequireAdmin)
        adminRoutes.Patch("/user/:id/ban", s.handler.user.BanUser)
        adminRoutes.Patch("/user/:id/unban", s.handler.user.UnbanUser)
        adminRoutes.Get("/lessee/pending", s.handler.user.GetPending)
        adminRoutes.Patch("/lessee/:id/verify", s.handler.user.VerifyStudentVerification)
        adminRoutes.Patch("/lessee/:id/reject", s.handler.user.RejectStudentVerification)
        adminRoutes.Get("/reviews/reported", s.handler.leasingHistory.GetReportedReviews)
        adminRoutes.Delete("/reviews/:id", s.handler.leasingHistory.DeleteReview)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package server

import (
        "context"
        "fmt"
        "log"

        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/PitiNarak/condormhub-backend/internal/middleware"
        "github.com/PitiNarak/condormhub-backend/pkg/email"
        "github.com/PitiNarak/condormhub-backend/pkg/jwt"
        "github.com/PitiNarak/condormhub-backend/pkg/redis"
        "github.com/PitiNarak/condormhub-backend/pkg/storage"
        "github.com/PitiNarak/condormhub-backend/pkg/stripe"
        "github.com/goccy/go-json"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "github.com/gofiber/fiber/v2/middleware/logger"
        "github.com/gofiber/fiber/v2/middleware/requestid"
        "github.com/yokeTH/go-pkg/apperror"
)

type Config struct {
        Name                 string `env:"NAME"`
        Port                 int    `env:"PORT"`
        Env                  string `env:"ENV"`
        MaxBodyLimitMB       int    `env:"MAX_BODY_LIMIT_MB"`
        CorsAllowOrigins     string `env:"CORS_ALLOW_ORIGINS"`
        CorsAllowMethods     string `env:"CORS_ALLOW_METHODS"`
        CorsAllowHeaders     string `env:"CORS_ALLOW_HEADERS"`
        CorsAllowCredentials bool   `env:"CORS_ALLOW_CREDENTIALS"`
}

type Server struct {
        app            *fiber.App
        config         Config
        storage        *storage.Storage
        jwtUtils       *jwt.JWTUtils
        authMiddleware *middleware.AuthMiddleware
        redis          *redis.Redis
        db             *database.Database
        smtpConfig     *email.SMTPConfig
        stripeConfig   *stripe.Config
        stripe         *stripe.Stripe
        handler        *handler
        service        *service
        repository     *repository
}

func NewServer(config Config, smtpConfig email.SMTPConfig, jwtConfig jwt.JWTConfig, storageConfig storage.Config, stripeConfig stripe.Config, redis *redis.Redis, db *database.Database) *Server <span class="cov0" title="0">{

        app := fiber.New(fiber.Config{
                AppName:               config.Name,
                BodyLimit:             config.MaxBodyLimitMB * 1024 * 1024,
                CaseSensitive:         true,
                JSONEncoder:           json.Marshal,
                JSONDecoder:           json.Unmarshal,
                DisableStartupMessage: true,
                ErrorHandler:          apperror.ErrorHandler,
        })

        jwtUtils := jwt.NewJWTUtils(&amp;jwtConfig, redis)
        storage := storage.NewStorage(storageConfig)
        stripe := stripe.New(stripeConfig)

        return &amp;Server{
                app:          app,
                config:       config,
                storage:      storage,
                jwtUtils:     jwtUtils,
                db:           db,
                redis:        redis,
                smtpConfig:   &amp;smtpConfig,
                stripeConfig: &amp;stripeConfig,
                stripe:       stripe,
        }
}</span>

func (s *Server) Start(ctx context.Context, stop context.CancelFunc) <span class="cov0" title="0">{

        s.initServerMiddleware()
        s.initRepository()
        s.initAuthMiddleware()

        s.initService()
        s.initHandler()
        s.initRoutes()

        // start server
        go func() </span><span class="cov0" title="0">{
                if err := s.app.Listen(fmt.Sprintf(":%d", s.config.Port)); err != nil </span><span class="cov0" title="0">{
                        log.Panicf("Failed to start server: %v\n", err)
                        stop()
                }</span>
        }()

        // shutdown server at the end
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := s.app.ShutdownWithContext(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to shutdown server: %v\n", err)
                }</span>
                <span class="cov0" title="0">log.Println("Server stopped")</span>
        }()

        <span class="cov0" title="0">&lt;-ctx.Done()

        log.Println("Server is shutting down...")</span>
}

func (s *Server) initServerMiddleware() <span class="cov0" title="0">{
        s.app.Use(cors.New(cors.Config{
                AllowOrigins:     s.config.CorsAllowOrigins,
                AllowMethods:     s.config.CorsAllowMethods,
                AllowHeaders:     s.config.CorsAllowHeaders,
                AllowCredentials: s.config.CorsAllowCredentials,
        }))

        s.app.Use(requestid.New())
        s.app.Use(logger.New(logger.Config{
                DisableColors: true,
        }))

}</span>

func (s *Server) initAuthMiddleware() <span class="cov0" title="0">{
        s.authMiddleware = middleware.NewAuthMiddleware(s.jwtUtils, s.repository.user)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package server

import (
        "github.com/PitiNarak/condormhub-backend/internal/core/ports"
        "github.com/PitiNarak/condormhub-backend/internal/core/services"
        "github.com/PitiNarak/condormhub-backend/pkg/email"
)

type service struct {
        user           ports.UserService
        dorm           ports.DormService
        leasingHistory ports.LeasingHistoryService
        order          ports.OrderService
        tsx            ports.TransactionService
        ownershipProof ports.OwnershipProofService
        contract       ports.ContractService
        leasingRequest ports.LeasingRequestService
        receipt        ports.ReceiptService
        support        ports.SupportService
}

func (s *Server) initService() <span class="cov0" title="0">{
        email := email.NewEmailService(s.smtpConfig, s.jwtUtils)
        user := services.NewUserService(s.repository.user, email, s.jwtUtils, s.storage)
        dorm := services.NewDormService(s.repository.dorm, s.storage)
        leasingHistory := services.NewLeasingHistoryService(s.repository.leasingHistory, s.repository.dorm, s.storage)
        order := services.NewOrderService(s.repository.order, s.repository.leasingHistory)
        ownershipProof := services.NewOwnershipProofService(s.repository.ownershipProof, s.repository.user, s.storage)
        contract := services.NewContractService(s.repository.contract, s.repository.user, s.repository.dorm, leasingHistory)
        leasingRequest := services.NewLeasingRequestService(s.repository.leasingRequest, s.repository.dorm, s.repository.contract)
        receipt := services.NewReceiptService(s.repository.receipt, s.repository.user, s.repository.tsx, s.repository.order, s.repository.leasingHistory, s.repository.dorm, s.storage)
        tsx := services.NewTransactionService(s.repository.tsx, s.repository.order, s.stripe, s.repository.leasingHistory, receipt)
        support := services.NewSupportService(s.repository.support)

        s.service = &amp;service{
                user:           user,
                dorm:           dorm,
                leasingHistory: leasingHistory,
                order:          order,
                tsx:            tsx,
                ownershipProof: ownershipProof,
                contract:       contract,
                leasingRequest: leasingRequest,
                receipt:        receipt,
                support:        support,
        }
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package main

import (
        "context"
        "os"
        "os/signal"
        "syscall"

        "github.com/PitiNarak/condormhub-backend/internal/config"
        "github.com/PitiNarak/condormhub-backend/internal/database"
        "github.com/PitiNarak/condormhub-backend/internal/server"
        "github.com/PitiNarak/condormhub-backend/pkg/redis"
        "github.com/gofiber/fiber/v2/log"
        // _ "github.com/PitiNarak/condormhub-backend/docs"
)

// @title Condormhub API
// @version 1.0
// @description This is the API for the Condormhub project.

// @securityDefinitions.apikey Bearer
// @in header
// @name Authorization
// @description Bearer token authentication
func main() <span class="cov0" title="0">{
        config := config.Load()
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM, syscall.SIGINT)
        defer stop()

        db, err := database.New(config.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Database connection failed: %v", err)
        }</span>

        <span class="cov0" title="0">redis, err := redis.New(config.Redis)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Redis connection failed: %v", err)
        }</span>

        <span class="cov0" title="0">s := server.NewServer(config.Server, config.SMTP, config.JWT, config.Storage, config.StripeConfig, redis, db)
        s.Start(ctx, stop)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package email

import (
        "fmt"
        "os"

        "github.com/PitiNarak/condormhub-backend/pkg/jwt"
        "github.com/go-gomail/gomail"
        "github.com/yokeTH/go-pkg/apperror"
)

type SMTPConfig struct {
        Host         string `env:"HOST,required"`
        Port         int    `env:"PORT,required"`
        Email        string `env:"EMAIL,required"`
        Password     string `env:"PASSWORD,required"`
        LinkHostname string `env:"LINK_HOSTNAME,required"`
}

type Email struct {
        emailConfig *SMTPConfig
        jwtUtils    *jwt.JWTUtils
}

func NewEmailService(emailConfig *SMTPConfig, jwtUtils *jwt.JWTUtils) Email <span class="cov0" title="0">{
        return Email{emailConfig: emailConfig, jwtUtils: jwtUtils}
}</span>

func (e *Email) SendVerificationEmail(email, name string, token string) error <span class="cov0" title="0">{
        message := gomail.NewMessage()
        message.SetHeader("From", "no-reply@condormhub.xyz")
        message.SetHeader("To", email)
        message.SetHeader("Subject", "ConDormHub Email Verification")
        cwd, _ := os.Getwd()
        verLink := fmt.Sprintf(e.emailConfig.LinkHostname+"/verify?token=%s", token)
        html, _ := readTemplate(cwd + "/pkg/email/verify-compress.html")
        body := fmt.Sprintf(html, name, verLink, verLink)
        message.SetBody("text/html", body)

        dailer := gomail.NewDialer(e.emailConfig.Host, e.emailConfig.Port, e.emailConfig.Email, e.emailConfig.Password)

        return dailer.DialAndSend(message)
}</span>

func (e *Email) SendResetPasswordEmail(email, name string, token string) error <span class="cov0" title="0">{
        message := gomail.NewMessage()
        message.SetHeader("From", "no-reply@condormhub.xyz")
        message.SetHeader("To", email)
        message.SetHeader("Subject", "ConDormHub Reset Password")

        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "cannot get current path")
        }</span>
        <span class="cov0" title="0">verLink := fmt.Sprintf(e.emailConfig.LinkHostname+"/newpassword/token=%s", token)
        html, err := readTemplate(cwd + "/pkg/email/reset-compress.html")
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "cannot load html template")
        }</span>
        <span class="cov0" title="0">body := fmt.Sprintf(html, name, verLink, verLink)
        message.SetBody("text/html", body)

        dailer := gomail.NewDialer(e.emailConfig.Host, e.emailConfig.Port, e.emailConfig.Email, e.emailConfig.Password)
        err = dailer.DialAndSend(message)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "cannot sent email")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func readTemplate(path string) (string, error) <span class="cov0" title="0">{
        byteContent, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{ //many people wrap this into a function
                return "", err
        }</span>
        <span class="cov0" title="0">return string(byteContent), nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package jwt

import (
        "context"
        "fmt"
        "time"

        "github.com/PitiNarak/condormhub-backend/pkg/redis"
        "github.com/golang-jwt/jwt/v4"
        "github.com/google/uuid"
        "github.com/yokeTH/go-pkg/apperror"
)

type JWTConfig struct {
        JWTSecretKey           string `env:"SECRET,required"`
        AccessTokenExpiration  int    `env:"EXPIRATION_HOURS,required"`
        RefreshTokenExpiration int    `env:"REFRESH_EXPIRATION_HOURS,required"`
}

type JWTUtils struct {
        Config *JWTConfig
        Redis  *redis.Redis
}

type JWTClaims struct {
        jwt.RegisteredClaims
        UserID string `json:"userID"`
}

type JWTClaimsInterface interface {
        GetUserID() string
        GetExp() int64
        GetIat() int64
}

func NewJWTUtils(config *JWTConfig, redis *redis.Redis) *JWTUtils <span class="cov0" title="0">{
        return &amp;JWTUtils{Config: config, Redis: redis}
}</span>

func (j *JWTClaims) GetUserID() string <span class="cov0" title="0">{
        return j.UserID
}</span>

func (j *JWTClaims) GetExp() int64 <span class="cov0" title="0">{
        return j.ExpiresAt.Unix()
}</span>

func (j *JWTClaims) GetIat() int64 <span class="cov0" title="0">{
        return j.IssuedAt.Unix()
}</span>

func (j *JWTUtils) GenerateJWT(userID uuid.UUID, exp int) (string, error) <span class="cov0" title="0">{
        claims := &amp;JWTClaims{
                UserID: userID.String(),
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * time.Duration(exp))),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := jwtToken.SignedString([]byte(j.Config.JWTSecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "cannot generate token")
        }</span>
        <span class="cov0" title="0">return tokenString, nil</span>
}

func (j *JWTUtils) DecodeJWT(inputToken string) (*JWTClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(inputToken, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(j.Config.JWTSecretKey), nil</span>
        })

        <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                return new(JWTClaims), apperror.UnauthorizedError(err, "parse token failed")
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(*JWTClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return new(JWTClaims), apperror.UnauthorizedError(err, "invalid token")
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

func (j *JWTUtils) GenerateKeyPair(ctx context.Context, userID uuid.UUID) (string, string, error) <span class="cov0" title="0">{
        accessToken, err := j.GenerateJWT(userID, j.Config.AccessTokenExpiration)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">err = j.Redis.SetAccessToken(ctx, userID, accessToken, time.Hour*time.Duration(j.Config.AccessTokenExpiration))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", apperror.InternalServerError(err, "cannot set access token")
        }</span>

        <span class="cov0" title="0">refreshToken, err := j.GenerateJWT(userID, j.Config.RefreshTokenExpiration)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">err = j.Redis.SetRefreshToken(ctx, userID, refreshToken, time.Hour*time.Duration(j.Config.RefreshTokenExpiration))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", apperror.InternalServerError(err, "cannot set refresh token")
        }</span>

        <span class="cov0" title="0">return accessToken, refreshToken, nil</span>
}

func (j *JWTUtils) VerifyAccessToken(ctx context.Context, accessToken string) (uuid.UUID, error) <span class="cov0" title="0">{
        claims, err := j.DecodeJWT(accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.InternalServerError(err, "cannot parse user id")
        }</span>

        <span class="cov0" title="0">token, err := j.Redis.GetAccessToken(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.InternalServerError(err, "cannot get access token")
        }</span>

        <span class="cov0" title="0">if token != accessToken </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.UnauthorizedError(nil, "invalid access token")
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}

func (j *JWTUtils) VerifyRefreshToken(ctx context.Context, refreshToken string) (uuid.UUID, error) <span class="cov0" title="0">{
        claims, err := j.DecodeJWT(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.InternalServerError(err, "cannot parse user id")
        }</span>

        <span class="cov0" title="0">token, err := j.Redis.GetRefreshToken(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.InternalServerError(err, "cannot get refresh token")
        }</span>

        <span class="cov0" title="0">if token != refreshToken </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.UnauthorizedError(nil, "invalid refresh token")
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}

func (j *JWTUtils) RefreshToken(ctx context.Context, refreshToken string) (string, string, error) <span class="cov0" title="0">{
        userID, err := j.VerifyRefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">accessToken, refreshToken, err := j.GenerateKeyPair(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">err = j.Redis.SetAccessToken(ctx, userID, accessToken, time.Hour*time.Duration(j.Config.AccessTokenExpiration))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", apperror.InternalServerError(err, "cannot set access token")
        }</span>

        <span class="cov0" title="0">return accessToken, refreshToken, nil</span>
}

func (j *JWTUtils) GenerateResetPasswordToken(ctx context.Context, userID uuid.UUID) (string, error) <span class="cov0" title="0">{
        resetToken, err := j.GenerateJWT(userID, 24)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">err = j.Redis.SetResetToken(ctx, userID, resetToken, time.Hour*24)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "cannot set reset token")
        }</span>
        <span class="cov0" title="0">return resetToken, nil</span>
}

func (j *JWTUtils) VerifyResetPasswordToken(ctx context.Context, resetToken string) (uuid.UUID, error) <span class="cov0" title="0">{
        claims, err := j.DecodeJWT(resetToken)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.InternalServerError(err, "cannot parse user id")
        }</span>

        <span class="cov0" title="0">token, err := j.Redis.GetResetToken(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.UnauthorizedError(err, "token is expired or token is used")
        }</span>

        <span class="cov0" title="0">if token != resetToken </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.UnauthorizedError(nil, "invalid reset token")
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}

func (j *JWTUtils) DeleteResetPasswordToken(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        err := j.Redis.DeleteResetToken(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "cannot delete reset token")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (j *JWTUtils) GenerateVerificationToken(ctx context.Context, userID uuid.UUID) (string, error) <span class="cov0" title="0">{
        verificationToken, err := j.GenerateJWT(userID, 24)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">err = j.Redis.SetVerificationToken(ctx, userID, verificationToken, time.Hour*24)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.InternalServerError(err, "cannot set verification token")
        }</span>
        <span class="cov0" title="0">return verificationToken, nil</span>
}

func (j *JWTUtils) VerifyVerificationToken(ctx context.Context, verificationToken string) (uuid.UUID, error) <span class="cov0" title="0">{
        claims, err := j.DecodeJWT(verificationToken)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.InternalServerError(err, "cannot parse user id")
        }</span>

        <span class="cov0" title="0">token, err := j.Redis.GetVerificationToken(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.UnauthorizedError(err, "token is expired or token is used")
        }</span>

        <span class="cov0" title="0">if token != verificationToken </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.UnauthorizedError(nil, "invalid verification token")
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}

func (j *JWTUtils) DeleteVerificationToken(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        err := j.Redis.DeleteVerificationToken(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.InternalServerError(err, "cannot delete verification token")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package redis

import (
        "github.com/redis/go-redis/v9"
)

type Config struct {
        Uri                   string `env:"URI"`
        AccessTokenExpireHrs  int    `env:"ACCESS_TOKEN_EXPIRE_HRS"`
        RefreshTokenExpireHrs int    `env:"REFRESH_TOKEN_EXPIRE_HRS"`
}

type Redis struct {
        client *redis.Client
}

func New(config Config) (*Redis, error) <span class="cov0" title="0">{
        options, err := redis.ParseURL(config.Uri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client := redis.NewClient(options)

        return &amp;Redis{
                client: client,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package redis

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
)

func (r *Redis) SetAccessToken(ctx context.Context, userId uuid.UUID, accessToken string, ttl time.Duration) error <span class="cov0" title="0">{
        accessTokenKey := fmt.Sprintf("access_token:%s", userId)

        err := r.client.Set(ctx, accessTokenKey, accessToken, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Redis) SetRefreshToken(ctx context.Context, userId uuid.UUID, refreshToken string, ttl time.Duration) error <span class="cov0" title="0">{
        refreshTokenKey := fmt.Sprintf("refresh_token:%s", userId)

        err := r.client.Set(ctx, refreshTokenKey, refreshToken, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Redis) GetAccessToken(ctx context.Context, userId uuid.UUID) (string, error) <span class="cov0" title="0">{
        accessTokenKey := fmt.Sprintf("access_token:%s", userId)

        accessToken, err := r.client.Get(ctx, accessTokenKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return accessToken, nil</span>
}

func (r *Redis) GetRefreshToken(ctx context.Context, userId uuid.UUID) (string, error) <span class="cov0" title="0">{
        refreshTokenKey := fmt.Sprintf("refresh_token:%s", userId)

        refreshToken, err := r.client.Get(ctx, refreshTokenKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return refreshToken, nil</span>
}

func (r *Redis) DeleteAccessTokenAndRefreshToken(ctx context.Context, userId uuid.UUID) error <span class="cov0" title="0">{
        accessTokenKey := fmt.Sprintf("access_token:%s", userId)

        err := r.client.Del(ctx, accessTokenKey).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">refreshTokenKey := fmt.Sprintf("refresh_token:%s", userId)
        err = r.client.Del(ctx, refreshTokenKey).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Redis) SetVerificationToken(ctx context.Context, userID uuid.UUID, token string, ttl time.Duration) error <span class="cov0" title="0">{
        verificationTokenKey := fmt.Sprintf("verification_token:%s", userID)

        err := r.client.Set(ctx, verificationTokenKey, token, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Redis) GetVerificationToken(ctx context.Context, userID uuid.UUID) (string, error) <span class="cov0" title="0">{
        verificationTokenKey := fmt.Sprintf("verification_token:%s", userID)

        token, err := r.client.Get(ctx, verificationTokenKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (r *Redis) DeleteVerificationToken(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        verificationTokenKey := fmt.Sprintf("verification_token:%s", userID)

        err := r.client.Del(ctx, verificationTokenKey).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Redis) SetResetToken(ctx context.Context, userID uuid.UUID, token string, ttl time.Duration) error <span class="cov0" title="0">{
        resetTokenKey := fmt.Sprintf("reset_token:%s", userID)

        err := r.client.Set(ctx, resetTokenKey, token, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Redis) GetResetToken(ctx context.Context, userID uuid.UUID) (string, error) <span class="cov0" title="0">{
        resetTokenKey := fmt.Sprintf("reset_token:%s", userID)

        token, err := r.client.Get(ctx, resetTokenKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (r *Redis) DeleteResetToken(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        resetTokenKey := fmt.Sprintf("reset_token:%s", userID)

        err := r.client.Del(ctx, resetTokenKey).Err()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package storage

import (
        "context"
        "fmt"
        "io"
        "log"
        "net/url"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

type BucketType string

const (
        PublicBucket  BucketType = "public"
        PrivateBucket BucketType = "private"
)

type Config struct {
        BucketName        string `env:"BUCKET_NAME"`
        PrivateBucketName string `env:"PRIVATE_BUCKET_NAME"`
        AccountID         string `env:"ACCOUNT_ID"`
        AccessKeyID       string `env:"ACCESS_KEY_ID"`
        AccessKeySecret   string `env:"ACCESS_KEY_SECRET"`
        URL_PREFIX        string `env:"URL_PREFIX"`
}

type Storage struct {
        client        *s3.Client
        presignClient *s3.PresignClient
        Config        Config
}

func newClient(storageConfig Config) *s3.Client <span class="cov0" title="0">{
        cfg, err := config.LoadDefaultConfig(context.TODO(),
                config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(storageConfig.AccessKeyID, storageConfig.AccessKeySecret, "")),
                config.WithRegion("auto"),
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">client := s3.NewFromConfig(cfg, func(o *s3.Options) </span><span class="cov0" title="0">{
                o.BaseEndpoint = aws.String(fmt.Sprintf("https://%s.r2.cloudflarestorage.com", storageConfig.AccountID))
        }</span>)

        <span class="cov0" title="0">return client</span>
}

func NewStorage(storageConfig Config) *Storage <span class="cov0" title="0">{
        client := newClient(storageConfig)
        presignClient := s3.NewPresignClient(client)

        return &amp;Storage{
                client:        client,
                Config:        storageConfig,
                presignClient: presignClient,
        }
}</span>

func (s *Storage) getBucketName(bucket BucketType) string <span class="cov0" title="0">{
        if bucket == PublicBucket </span><span class="cov0" title="0">{
                return s.Config.BucketName
        }</span> else<span class="cov0" title="0"> {
                return s.Config.PrivateBucketName
        }</span>
}

func (s *Storage) UploadFile(ctx context.Context, key string, contentType string, file io.Reader, bucketType BucketType) error <span class="cov0" title="0">{
        _, err := s.client.PutObject(ctx, &amp;s3.PutObjectInput{
                Bucket:      aws.String(s.getBucketName(bucketType)),
                Key:         aws.String(key),
                ContentType: &amp;contentType,
                Body:        file,
        })

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Storage) DeleteFile(ctx context.Context, key string, bucketType BucketType) error <span class="cov0" title="0">{
        _, err := s.client.DeleteObject(ctx, &amp;s3.DeleteObjectInput{
                Bucket: aws.String(s.getBucketName(bucketType)),
                Key:    aws.String(key),
        })

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Storage) CopyFile(ctx context.Context, sourceKey string, destKey string, bucketType BucketType) error <span class="cov0" title="0">{
        _, err := s.client.CopyObject(ctx, &amp;s3.CopyObjectInput{
                Bucket:     aws.String(s.getBucketName(bucketType)),
                CopySource: aws.String(sourceKey),
                Key:        aws.String(destKey),
        })

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Storage) MoveFile(ctx context.Context, sourceKey string, destKey string, bucketType BucketType) error <span class="cov0" title="0">{
        err := s.CopyFile(ctx, sourceKey, destKey, bucketType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.DeleteFile(ctx, sourceKey, bucketType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Storage) GetSignedUrl(ctx context.Context, key string, expires time.Duration) (string, error) <span class="cov0" title="0">{
        req, err := s.presignClient.PresignGetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(s.Config.PrivateBucketName),
                Key:    aws.String(key),
        }, s3.WithPresignExpires(expires))

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return req.URL, nil</span>
}

func (s *Storage) GetPublicUrl(key string) string <span class="cov0" title="0">{
        return fmt.Sprintf(s.Config.URL_PREFIX, key)
}</span>

func (s *Storage) GetFileKeyFromPublicUrl(imageURL string) (string, error) <span class="cov0" title="0">{
        parsedURL, err := url.Parse(imageURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">fileKey := strings.TrimPrefix(parsedURL.Path, "/")

        return fileKey, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package stripe

import (
        "github.com/stripe/stripe-go/v81"
        "github.com/stripe/stripe-go/v81/checkout/session"
)

type Config struct {
        StripePublishableKey string `env:"PUBLISHABLE_KEY"`
        StripeSecretKey      string `env:"SECRET_KEY"`
        StripeSignatureKey   string `env:"SIGNATURE_KEY"`
        StripeSuccessURL     string `env:"SUCCESS_URL"`
        StripeCancelURL      string `env:"CANCEL_URL"`
}

type Stripe struct {
        config Config
}

func New(config Config) *Stripe <span class="cov0" title="0">{
        return &amp;Stripe{config: config}
}</span>

func (s *Stripe) createSession(params *stripe.CheckoutSessionParams) (*stripe.CheckoutSession, error) <span class="cov0" title="0">{
        stripe.Key = s.config.StripeSecretKey
        return session.New(params)
}</span>

func (s *Stripe) CreateOneTimePaymentSession(productName string, price int64, customerEmail string) (*stripe.CheckoutSession, error) <span class="cov0" title="0">{
        stripeParams := &amp;stripe.CheckoutSessionParams{
                Mode: stripe.String(string(stripe.CheckoutSessionModePayment)),
                LineItems: []*stripe.CheckoutSessionLineItemParams{
                        {
                                PriceData: &amp;stripe.CheckoutSessionLineItemPriceDataParams{
                                        Currency: stripe.String("thb"),
                                        ProductData: &amp;stripe.CheckoutSessionLineItemPriceDataProductDataParams{
                                                Name: stripe.String(productName),
                                        },
                                        UnitAmount: stripe.Int64(price * 100),
                                },
                                Quantity: stripe.Int64(1),
                        },
                },
                CustomerEmail: stripe.String(customerEmail),
                SuccessURL:    stripe.String(s.config.StripeSuccessURL),
                CancelURL:     stripe.String(s.config.StripeCancelURL),
        }

        return s.createSession(stripeParams)
}</span>

func (s *Stripe) CreateSubscriptionSession(productName string, price int64, customerEmail string) (*stripe.CheckoutSession, error) <span class="cov0" title="0">{
        stripeParams := &amp;stripe.CheckoutSessionParams{
                Mode: stripe.String(string(stripe.CheckoutSessionModeSubscription)),
                LineItems: []*stripe.CheckoutSessionLineItemParams{
                        {
                                PriceData: &amp;stripe.CheckoutSessionLineItemPriceDataParams{
                                        Currency: stripe.String("thb"),
                                        ProductData: &amp;stripe.CheckoutSessionLineItemPriceDataProductDataParams{
                                                Name: stripe.String(productName),
                                        },
                                        UnitAmount: stripe.Int64(price * 100),
                                        Recurring: &amp;stripe.CheckoutSessionLineItemPriceDataRecurringParams{
                                                Interval: stripe.String(string(stripe.PriceRecurringIntervalMonth)),
                                        },
                                },
                                Quantity: stripe.Int64(1),
                        },
                },
                CustomerEmail: stripe.String(customerEmail),
                SuccessURL:    stripe.String(s.config.StripeSuccessURL),
                CancelURL:     stripe.String(s.config.StripeCancelURL),
        }

        return s.createSession(stripeParams)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package swagger

import (
        "fmt"
        "net/http"

        "github.com/MarceloPetrucio/go-scalar-api-reference"
        "github.com/PitiNarak/condormhub-backend/docs"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/adaptor"
)

type swagger struct {
}

func New() *swagger <span class="cov0" title="0">{
        return &amp;swagger{}
}</span>

func (s *swagger) Handler() fiber.Handler <span class="cov0" title="0">{
        return adaptor.HTTPHandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                htmlContent, err := scalar.ApiReferenceHTML(&amp;scalar.Options{
                        SpecContent: docs.SwaggerInfo.ReadDoc(),
                })

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("%v", err)
                }</span>

                <span class="cov0" title="0">fmt.Fprintln(w, htmlContent)</span>
        })
}

var (
        instance = New()
        Handler  = instance.Handler()
)
</pre>
		
		<pre class="file" id="file62" style="display: none">package utils

import (
        "errors"
        "regexp"

        "github.com/PitiNarak/condormhub-backend/internal/core/domain"
        "github.com/go-playground/validator/v10"
        "github.com/yokeTH/go-pkg/apperror"
)

// Custom validator for Lifestyles
func ValidateLifestyles(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        lifestyles, ok := fl.Field().Interface().([]string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, l := range lifestyles </span><span class="cov0" title="0">{
                if !domain.Lifestyle(l).IsValid() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Custom validator for Phone
func ValidatePhone(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        var phoneRegex = regexp.MustCompile(`^0\d{2}-\d{3}-\d{4}$`)
        return phoneRegex.MatchString(fl.Field().String())
}</span>

func ValidateRole(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        if fl.Field().IsValid() </span><span class="cov0" title="0">{
                role := fl.Field().String()
                return role == "ADMIN" || role == "LESSOR" || role == "LESSEE"
        }</span>
        <span class="cov0" title="0">return false</span>

}

func ValidateUserForReview(user *domain.User, history *domain.LeasingHistory, create bool) error <span class="cov0" title="0">{
        if create &amp;&amp; history.ReviewFlag </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("review already exist"), "review already exist")
        }</span> else<span class="cov0" title="0"> if !create &amp;&amp; !history.ReviewFlag </span><span class="cov0" title="0">{
                return apperror.BadRequestError(errors.New("review not exist"), "review not exist")
        }</span>
        <span class="cov0" title="0">if user.Role == domain.LessorRole </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("user is unauthorized"), "user is unauthorized")
        }</span>
        <span class="cov0" title="0">if history.LesseeID != user.ID &amp;&amp; user.Role != domain.AdminRole </span><span class="cov0" title="0">{
                return apperror.UnauthorizedError(errors.New("user is unauthorized"), "user is unauthorized")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
